# Objective: One-shot build/pack/deploy workflow for OpenPCC v0.002.
# - Stage A: build/pack/deploy server-1 + server-3, then capture server-1 address.
# - Stage B: build/pack/deploy server-2 + server-4 using server-1 address.
# - Image tag is derived from the commit SHA.
# - Compute EIF is built during server-2 deploy (no S3 input needed).
name: OpenPCC v0.002 One-shot Deploy

on:
  workflow_dispatch:
    inputs:
      aws_region:
        type: string
        description: AWS region
        default: ""
      subnet_id:
        type: string
        description: Subnet ID for instances
        default: ""
      router_security_group_id:
        type: string
        description: Security group ID for server-1 (router/gateway)
        default: ""
      compute_security_group_id:
        type: string
        description: Security group ID for server-2 (compute)
        default: ""
      auth_security_group_id:
        type: string
        description: Security group ID for server-3 (auth)
        default: ""
      relay_security_group_id:
        type: string
        description: Security group ID for server-4 (relay)
        default: ""
      instance_profile_arn:
        type: string
        description: Optional IAM instance profile ARN for EC2 (leave blank for public registry pulls)
        default: ""
      image_registry:
        type: string
        description: Public image registry base (e.g., public.ecr.aws/alias) when no instance profile
        default: ""
      key_name:
        type: string
        description: Optional EC2 key pair name
        default: ""
      enable_server3:
        type: boolean
        description: Enable server-3 build/deploy
        default: true
      ami_id:
        type: string
        description: Base AMI ID (Ubuntu 22.04 recommended)
        default: ""
      compute_instance_type:
        type: string
        description: server-2 instance type (Nitro Enclaves enabled)
        default: "c6a.4xlarge"
      edge_instance_type:
        type: string
        description: server-1/3/4 instance type
        default: "t3.small"
      enable_compute_monitor:
        type: boolean
        description: Install compute monitor on server-2 (debug only)
        default: true
      enable_fake_attestation_for_server2:
        type: boolean
        description: Enable fake attestation for server-2 build (do not combine with real attestation for client)
        default: true
      enclave_cpu_count:
        type: string
        description: Enclave CPU count
        default: ""
      enclave_memory_mib:
        type: string
        description: Enclave memory (MiB)
        default: ""
      enclave_cid:
        type: string
        description: Enclave CID for VSOCK connections
        default: "16"
      enable_ohttp:
        type: boolean
        description: Enable oHTTP config in server-3 (requires relay URLs and seeds)
        default: false
      enable_real_attestation_for_client:
        type: boolean
        description: Enable real attestation policy for clients (do not combine with fake attestation for server-2)
        default: false

env:
  IMAGE_TAG: ${{ github.sha }}
  SERVER3_IMAGE_NAME: ${{ vars.OPENPCC_AUTH_IMAGE_NAME != '' && vars.OPENPCC_AUTH_IMAGE_NAME || 'openpcc-auth' }}
  SERVER4_IMAGE_NAME: ${{ vars.OPENPCC_RELAY_IMAGE_NAME != '' && vars.OPENPCC_RELAY_IMAGE_NAME || 'openpcc-relay' }}

jobs:
  stage-a:
    name: Stage A (server-1 + server-3)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      server1_internal_addr: ${{ steps.resolve-server1.outputs.server1_internal_addr }}
      server1_router_url: ${{ steps.resolve-server1.outputs.server1_router_url }}
      server1_gateway_url: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
    env:
      RESOLVED_AWS_REGION: ${{ inputs.aws_region != '' && inputs.aws_region || vars.OPENPCC_AWS_REGION || 'us-east-1' }}
      RESOLVED_SUBNET_ID: ${{ inputs.subnet_id != '' && inputs.subnet_id || vars.OPENPCC_SUBNET_ID }}
      RESOLVED_ROUTER_SECURITY_GROUP_ID: ${{ inputs.router_security_group_id != '' && inputs.router_security_group_id || vars.OPENPCC_ROUTER_SECURITY_GROUP_ID }}
      RESOLVED_AUTH_SECURITY_GROUP_ID: ${{ inputs.auth_security_group_id != '' && inputs.auth_security_group_id || vars.OPENPCC_AUTH_SECURITY_GROUP_ID }}
      RESOLVED_INSTANCE_PROFILE_ARN: ${{ inputs.instance_profile_arn != '' && inputs.instance_profile_arn || vars.OPENPCC_INSTANCE_PROFILE_ARN }}
      RESOLVED_KEY_NAME: ${{ inputs.key_name != '' && inputs.key_name || vars.OPENPCC_KEY_NAME }}
      RESOLVED_ENABLE_SERVER3: ${{ inputs.enable_server3 }}
      RESOLVED_AMI_ID: ${{ inputs.ami_id != '' && inputs.ami_id || vars.OPENPCC_AMI_ID }}
      RESOLVED_EDGE_INSTANCE_TYPE: ${{ inputs.edge_instance_type }}
      RESOLVED_GATEWAY_PORT: "3200"
      RESOLVED_OHTTP_SEEDS_SECRET_REF: ${{ vars.OPENPCC_OHTTP_SEEDS_SECRET_REF != '' && vars.OPENPCC_OHTTP_SEEDS_SECRET_REF || '' }}
      RESOLVED_ENABLE_OHTTP: ${{ inputs.enable_ohttp }}
      RESOLVED_ENABLE_REAL_ATTESTATION_FOR_CLIENT: ${{ inputs.enable_real_attestation_for_client }}
      RESOLVED_ENABLE_FAKE_ATTESTATION_FOR_SERVER2: ${{ inputs.enable_fake_attestation_for_server2 }}
      RESOLVED_RELAY_URLS_JSON: ${{ vars.OPENPCC_RELAY_URLS_JSON != '' && vars.OPENPCC_RELAY_URLS_JSON || '' }}
      RESOLVED_OHTTP_SEEDS_JSON: ${{ secrets.OPENPCC_OHTTP_SEEDS_JSON != '' && secrets.OPENPCC_OHTTP_SEEDS_JSON || vars.OPENPCC_OHTTP_SEEDS_JSON || '' }}
      RESOLVED_ATTESTATION_POLICY_ID: ${{ vars.OPENPCC_ATTESTATION_POLICY_ID != '' && vars.OPENPCC_ATTESTATION_POLICY_ID || '' }}
      RESOLVED_ATTESTATION_ALLOWED_JSON: ${{ secrets.OPENPCC_ATTESTATION_ALLOWED_JSON != '' && secrets.OPENPCC_ATTESTATION_ALLOWED_JSON || vars.OPENPCC_ATTESTATION_ALLOWED_JSON || '' }}
      RESOLVED_ATTESTATION_VERIFIER_HINTS_JSON: ${{ secrets.OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON != '' && secrets.OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON || vars.OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON || '' }}
    steps:
      - name: Preflight validate config inputs
        env:
          ENABLE_SERVER3: ${{ env.RESOLVED_ENABLE_SERVER3 }}
          ENABLE_OHTTP: ${{ env.RESOLVED_ENABLE_OHTTP }}
          ENABLE_REAL_ATTESTATION_FOR_CLIENT: ${{ env.RESOLVED_ENABLE_REAL_ATTESTATION_FOR_CLIENT }}
          ENABLE_FAKE_ATTESTATION_FOR_SERVER2: ${{ env.RESOLVED_ENABLE_FAKE_ATTESTATION_FOR_SERVER2 }}
          RELAY_URLS_JSON: ${{ env.RESOLVED_RELAY_URLS_JSON }}
          OHTTP_SEEDS_JSON: ${{ env.RESOLVED_OHTTP_SEEDS_JSON }}
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
          ATTESTATION_POLICY_ID: ${{ env.RESOLVED_ATTESTATION_POLICY_ID }}
          ATTESTATION_ALLOWED_JSON: ${{ env.RESOLVED_ATTESTATION_ALLOWED_JSON }}
          ATTESTATION_VERIFIER_HINTS_JSON: ${{ env.RESOLVED_ATTESTATION_VERIFIER_HINTS_JSON }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json
          import os
          import sys

          def parse_bool(value, name, default):
              if value is None or str(value).strip() == "":
                  return default
              lowered = str(value).strip().lower()
              if lowered in ("true", "1", "yes", "y"):
                  return True
              if lowered in ("false", "0", "no", "n"):
                  return False
              raise SystemExit(f"{name} must be true/false (got '{value}')")

          def require(name, value):
              if value is None or str(value).strip() == "":
                  raise SystemExit(f"Missing required value: {name}")

          def parse_json(name, raw, expected_type):
              try:
                  data = json.loads(raw)
              except json.JSONDecodeError as exc:
                  raise SystemExit(f"{name} must be valid JSON: {exc}") from exc
              if not isinstance(data, expected_type):
                  raise SystemExit(f"{name} must be a {expected_type.__name__} JSON value")
              return data

          enable_server3 = parse_bool(os.getenv("ENABLE_SERVER3"), "ENABLE_SERVER3", True)
          enable_ohttp = parse_bool(os.getenv("ENABLE_OHTTP"), "ENABLE_OHTTP", False)
          enable_real = parse_bool(
              os.getenv("ENABLE_REAL_ATTESTATION_FOR_CLIENT"),
              "ENABLE_REAL_ATTESTATION_FOR_CLIENT",
              False,
          )
          enable_fake = parse_bool(
              os.getenv("ENABLE_FAKE_ATTESTATION_FOR_SERVER2"),
              "ENABLE_FAKE_ATTESTATION_FOR_SERVER2",
              False,
          )

          if enable_real and enable_fake:
              raise SystemExit(
                  "enable_fake_attestation_for_server2=true is not consistent with "
                  "enable_real_attestation_for_client=true. Disable one of them."
              )

          if enable_server3 and enable_ohttp:
              relay_raw = os.getenv("RELAY_URLS_JSON", "")
              seeds_raw = os.getenv("OHTTP_SEEDS_JSON", "")
              seeds_ref = os.getenv("OHTTP_SEEDS_SECRET_REF", "")
              require("OPENPCC_RELAY_URLS_JSON", relay_raw)
              relay = parse_json("OPENPCC_RELAY_URLS_JSON", relay_raw, list)
              if not relay:
                  raise SystemExit("OPENPCC_RELAY_URLS_JSON must be a non-empty list")
              for idx, item in enumerate(relay):
                  if not isinstance(item, str) or not item.strip():
                      raise SystemExit(
                          f"OPENPCC_RELAY_URLS_JSON[{idx}] must be a non-empty string"
                      )
              require("OPENPCC_OHTTP_SEEDS_JSON", seeds_raw)
              seeds = parse_json("OPENPCC_OHTTP_SEEDS_JSON", seeds_raw, list)
              if not seeds:
                  raise SystemExit("OPENPCC_OHTTP_SEEDS_JSON must be a non-empty list")
              for idx, seed in enumerate(seeds):
                  if not isinstance(seed, dict):
                      raise SystemExit(f"OPENPCC_OHTTP_SEEDS_JSON[{idx}] must be an object")
                  for key in ("key_id", "seed_hex", "active_from", "active_until"):
                      value = seed.get(key)
                      if not isinstance(value, str) or not value.strip():
                          raise SystemExit(
                              f"OPENPCC_OHTTP_SEEDS_JSON[{idx}].{key} must be a non-empty string"
                          )
              require("OPENPCC_OHTTP_SEEDS_SECRET_REF", seeds_ref)

          att_policy_id = os.getenv("ATTESTATION_POLICY_ID", "")
          allowed_raw = os.getenv("ATTESTATION_ALLOWED_JSON", "")
          hints_raw = os.getenv("ATTESTATION_VERIFIER_HINTS_JSON", "")
          if enable_server3 and enable_real:
              require("OPENPCC_ATTESTATION_POLICY_ID", att_policy_id)
              require("OPENPCC_ATTESTATION_ALLOWED_JSON", allowed_raw)
              require("OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON", hints_raw)
              parse_json("OPENPCC_ATTESTATION_ALLOWED_JSON", allowed_raw, dict)
              parse_json("OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON", hints_raw, dict)
          elif enable_server3:
              if (
                  str(att_policy_id).strip()
                  or str(allowed_raw).strip()
                  or str(hints_raw).strip()
              ):
                  raise SystemExit(
                      "attestation inputs provided but enable_real_attestation_for_client=false"
                  )
          PY

      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate AWS_ROLE_ARN
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
        run: |
          set -euo pipefail
          if [ -z "${AWS_ROLE_ARN}" ]; then
            echo "::error::Missing GitHub Actions secret AWS_ROLE_ARN."
            echo "::error::Set AWS_ROLE_ARN to the IAM Role ARN for GitHub Actions OIDC."
            echo "::error::Do not use Instance Profile ARN here."
            echo "::error::AWS Console: IAM -> Roles -> <role> -> ARN"
            echo "::error::CLI: aws iam get-role --role-name <ROLE_NAME> --query Role.Arn --output text"
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.RESOLVED_AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        if: ${{ inputs.image_registry == '' && vars.OPENPCC_IMAGE_REGISTRY == '' }}
        uses: aws-actions/amazon-ecr-login@v2

      - name: Resolve image registry
        id: resolve-registry
        env:
          INPUT_IMAGE_REGISTRY: ${{ inputs.image_registry }}
          VAR_IMAGE_REGISTRY: ${{ vars.OPENPCC_IMAGE_REGISTRY }}
          PRIVATE_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          set -euo pipefail
          if [ -n "${INPUT_IMAGE_REGISTRY}" ]; then
            resolved="${INPUT_IMAGE_REGISTRY}"
          elif [ -n "${VAR_IMAGE_REGISTRY}" ]; then
            resolved="${VAR_IMAGE_REGISTRY}"
          else
            resolved="${PRIVATE_REGISTRY}"
          fi
          echo "IMAGE_REGISTRY=${resolved}" >> "$GITHUB_ENV"
          if [[ "${resolved}" == public.ecr.aws/* ]]; then
            echo "IMAGE_REGISTRY_IS_PUBLIC=true" >> "$GITHUB_ENV"
          else
            echo "IMAGE_REGISTRY_IS_PUBLIC=false" >> "$GITHUB_ENV"
          fi

      - name: Login to public ECR
        if: ${{ env.IMAGE_REGISTRY_IS_PUBLIC == 'true' }}
        run: |
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws

      - name: Ensure ECR repositories (server-1/3)
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          ROUTER_IMAGE_NAME: openpcc-router
          AUTH_IMAGE_NAME: ${{ env.SERVER3_IMAGE_NAME }}
          ENABLE_SERVER3: ${{ env.RESOLVED_ENABLE_SERVER3 }}
        run: |
          set -euo pipefail
          IMAGE_REGISTRY_IS_PUBLIC="${IMAGE_REGISTRY_IS_PUBLIC:-false}"
          ensure_repo() {
            local name="$1"
            if [[ "${IMAGE_REGISTRY_IS_PUBLIC}" == "true" ]]; then
              local public_region="us-east-1"
              if ! aws ecr-public describe-repositories --region "${public_region}" --repository-names "${name}" >/dev/null 2>&1; then
                echo "Creating public ECR repository: ${name}"
                aws ecr-public create-repository --region "${public_region}" --repository-name "${name}" >/dev/null
              else
                echo "Public ECR repository exists: ${name}"
              fi
            else
              if ! aws ecr describe-repositories --region "${AWS_REGION}" --repository-names "${name}" >/dev/null 2>&1; then
                echo "Creating ECR repository: ${name}"
                aws ecr create-repository --region "${AWS_REGION}" --repository-name "${name}" >/dev/null
              else
                echo "ECR repository exists: ${name}"
              fi
            fi
          }
          ensure_repo "${ROUTER_IMAGE_NAME}"
          if [[ "${ENABLE_SERVER3}" == "true" ]]; then
            ensure_repo "${AUTH_IMAGE_NAME}"
          else
            echo "server-3 disabled; skipping auth repository creation."
          fi

      - name: Validate stage A inputs
        run: |
          set -euo pipefail
          IMAGE_REGISTRY_IS_PUBLIC="${IMAGE_REGISTRY_IS_PUBLIC:-false}"
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "subnet_id" "${RESOLVED_SUBNET_ID}"
          require "router_security_group_id" "${RESOLVED_ROUTER_SECURITY_GROUP_ID}"
          require "ami_id" "${RESOLVED_AMI_ID}"
          if [ -z "${RESOLVED_INSTANCE_PROFILE_ARN}" ] && [ "${IMAGE_REGISTRY_IS_PUBLIC}" != "true" ]; then
            echo "instance_profile_arn is empty; set image_registry to a public registry (public.ecr.aws/alias)." >&2
            missing=1
          fi
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Build server-1 image
        env:
          COMPONENT: server-1
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ env.IMAGE_REGISTRY }}
        run: bash scripts/build_pack.sh

      - name: Build server-3 image (if present)
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('server-3/Dockerfile') != '' }}
        env:
          COMPONENT: server-3
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ env.IMAGE_REGISTRY }}
          AUTH_IMAGE_NAME: ${{ env.SERVER3_IMAGE_NAME }}
        run: bash scripts/build_pack.sh

      - name: Skip server-3 build
        if: ${{ env.RESOLVED_ENABLE_SERVER3 != 'true' }}
        run: echo "::notice::server-3 build disabled; skipping."

      - name: Skip server-3 build (Dockerfile missing)
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('server-3/Dockerfile') == '' }}
        run: echo "::warning::server-3 Dockerfile not found; skipping build."

      - name: Deploy server-1
        env:
          COMPONENT: server-1
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ env.IMAGE_REGISTRY }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          ROUTER_SECURITY_GROUP_ID: ${{ env.RESOLVED_ROUTER_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          ROUTER_INSTANCE_TYPE: ${{ env.RESOLVED_EDGE_INSTANCE_TYPE }}
          # NOTE: Passed through for future gateway key sync. server-1 does not consume yet.
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
        run: bash scripts/deploy_server1.sh

      - name: Resolve server-1 address
        id: resolve-server1
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          GATEWAY_PORT: "3200"
        run: |
          set -euo pipefail
          instance_id=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --filters "Name=tag:Name,Values=openpcc-router" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId | [0]" \
            --output text)
          if [ -z "${instance_id}" ] || [ "${instance_id}" = "None" ]; then
            echo "Failed to find running server-1 instance (tag Name=openpcc-router)." >&2
            exit 1
          fi
          private_ip=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --instance-ids "${instance_id}" \
            --query "Reservations[0].Instances[0].PrivateIpAddress" \
            --output text)
          if [ -z "${private_ip}" ] || [ "${private_ip}" = "None" ]; then
            echo "Failed to resolve server-1 private IP." >&2
            exit 1
          fi
          # Router port is fixed at 3600. Gateway port is configurable.
          router_url="http://${private_ip}:3600"
          gateway_url="http://${private_ip}:${GATEWAY_PORT}"
          echo "server1_internal_addr=${private_ip}" >> "${GITHUB_OUTPUT}"
          echo "server1_router_url=${router_url}" >> "${GITHUB_OUTPUT}"
          echo "server1_gateway_url=${gateway_url}" >> "${GITHUB_OUTPUT}"

      - name: Build server-3 config
        id: build-server3-config
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('scripts/deploy_server3.sh') != '' }}
        env:
          ENABLE_OHTTP: ${{ env.RESOLVED_ENABLE_OHTTP }}
          ENABLE_REAL_ATTESTATION_FOR_CLIENT: ${{ env.RESOLVED_ENABLE_REAL_ATTESTATION_FOR_CLIENT }}
          ENABLE_FAKE_ATTESTATION_FOR_SERVER2: ${{ env.RESOLVED_ENABLE_FAKE_ATTESTATION_FOR_SERVER2 }}
          RELAY_URLS_JSON: ${{ env.RESOLVED_RELAY_URLS_JSON }}
          OHTTP_SEEDS_JSON: ${{ env.RESOLVED_OHTTP_SEEDS_JSON }}
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
          ATTESTATION_POLICY_ID: ${{ env.RESOLVED_ATTESTATION_POLICY_ID }}
          ATTESTATION_ALLOWED_JSON: ${{ env.RESOLVED_ATTESTATION_ALLOWED_JSON }}
          ATTESTATION_VERIFIER_HINTS_JSON: ${{ env.RESOLVED_ATTESTATION_VERIFIER_HINTS_JSON }}
          SERVER1_ROUTER_URL: ${{ steps.resolve-server1.outputs.server1_router_url }}
          SERVER1_GATEWAY_URL: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
        run: |
          set -euo pipefail
          config_path="${RUNNER_TEMP}/server-3.config.json"
          python3 - <<'PY' "${config_path}"
          import json
          import os
          import sys

          def parse_bool(value, name, default):
              if value is None or value.strip() == "":
                  return default
              lowered = value.strip().lower()
              if lowered in ("true", "1", "yes", "y"):
                  return True
              if lowered in ("false", "0", "no", "n"):
                  return False
              raise SystemExit(f"{name} must be true/false (got '{value}')")

          def parse_json(raw, name, required, expected_type):
              if raw.strip() == "":
                  if required:
                      raise SystemExit(f"{name} is required")
                  return expected_type()
              try:
                  data = json.loads(raw)
              except json.JSONDecodeError as exc:
                  raise SystemExit(f"{name} must be valid JSON: {exc}") from exc
              if not isinstance(data, expected_type):
                  raise SystemExit(f"{name} must be a {expected_type.__name__} JSON value")
              return data

          def ensure_non_empty_list(values, name):
              if not values:
                  raise SystemExit(f"{name} must be a non-empty list")
              for idx, item in enumerate(values):
                  if not isinstance(item, str) or not item.strip():
                      raise SystemExit(f"{name}[{idx}] must be a non-empty string")

          enable_ohttp = parse_bool(os.getenv("ENABLE_OHTTP"), "ENABLE_OHTTP", True)
          enable_real_attestation_for_client = parse_bool(
              os.getenv("ENABLE_REAL_ATTESTATION_FOR_CLIENT"),
              "ENABLE_REAL_ATTESTATION_FOR_CLIENT",
              True,
          )
          enable_fake_attestation_for_server2 = parse_bool(
              os.getenv("ENABLE_FAKE_ATTESTATION_FOR_SERVER2"),
              "ENABLE_FAKE_ATTESTATION_FOR_SERVER2",
              False,
          )

          if enable_fake_attestation_for_server2 and enable_real_attestation_for_client:
              raise SystemExit(
                  "enable_fake_attestation_for_server2=true is not consistent with "
                  "enable_real_attestation_for_client=true. Disable one of them."
              )

          server1_router_url = os.getenv("SERVER1_ROUTER_URL", "").strip()
          server1_gateway_url = os.getenv("SERVER1_GATEWAY_URL", "").strip()
          relay_urls_raw = os.getenv("RELAY_URLS_JSON", "")
          seeds_raw = os.getenv("OHTTP_SEEDS_JSON", "")
          seeds_secret_ref = os.getenv("OHTTP_SEEDS_SECRET_REF", "").strip()

          if enable_ohttp:
              if not server1_router_url or not server1_gateway_url:
                  raise SystemExit("SERVER1_ROUTER_URL and SERVER1_GATEWAY_URL are required for oHTTP")
              relay_urls = parse_json(relay_urls_raw, "relay_urls_json", True, list)
              ensure_non_empty_list(relay_urls, "relay_urls_json")
              seeds = parse_json(seeds_raw, "ohttp_seeds_json", True, list)
              if not seeds:
                  raise SystemExit("ohttp_seeds_json must be a non-empty list")
              if not seeds_secret_ref:
                  raise SystemExit("ohttp_seeds_secret_ref is required when oHTTP is enabled")
              seen_ids = set()
              for idx, seed in enumerate(seeds):
                  if not isinstance(seed, dict):
                      raise SystemExit(f"ohttp_seeds_json[{idx}] must be an object")
                  for key in ("key_id", "seed_hex", "active_from", "active_until"):
                      value = seed.get(key)
                      if not isinstance(value, str) or not value.strip():
                          raise SystemExit(f"ohttp_seeds_json[{idx}].{key} must be a non-empty string")
                  key_id = seed["key_id"]
                  if key_id in seen_ids:
                      raise SystemExit(f"ohttp_seeds_json[{idx}].key_id is duplicated: {key_id}")
                  seen_ids.add(key_id)
          else:
              if relay_urls_raw.strip() or seeds_raw.strip() or seeds_secret_ref:
                  raise SystemExit("oHTTP inputs provided but enable_ohttp=false")
              relay_urls = []
              seeds = []

          att_policy_id = os.getenv("ATTESTATION_POLICY_ID", "").strip()
          allowed_raw = os.getenv("ATTESTATION_ALLOWED_JSON", "")
          verifier_hints_raw = os.getenv("ATTESTATION_VERIFIER_HINTS_JSON", "")

          if enable_real_attestation_for_client:
              if not att_policy_id:
                  raise SystemExit(
                      "attestation_policy_id is required when real attestation for client is enabled"
                  )
              allowed = parse_json(allowed_raw, "attestation_allowed_json", False, dict)
              verifier_hints = parse_json(
                  verifier_hints_raw, "attestation_verifier_hints_json", False, dict
              )
          else:
              if att_policy_id or allowed_raw.strip() or verifier_hints_raw.strip():
                  raise SystemExit(
                      "attestation inputs provided but enable_real_attestation_for_client=false"
                  )
              allowed = {}
              verifier_hints = {}

          payload = {
              "version": "0.002",
              "features": {
                  "ohttp": enable_ohttp,
                  "real_attestation": enable_real_attestation_for_client,
              },
          }

          if enable_ohttp:
              payload.update(
                  {
                      "relay_urls": relay_urls,
                      "gateway_url": server1_gateway_url,
                      "router_url": server1_router_url,
                      "ohttp_seeds": seeds,
                  }
              )

          if enable_real_attestation_for_client:
              attestation = {
                  "policy_id": att_policy_id,
              }
              if allowed:
                  attestation["allowed"] = allowed
              if verifier_hints:
                  attestation["verifier_hints"] = verifier_hints
              payload["attestation"] = attestation

          with open(sys.argv[1], "w", encoding="utf-8") as handle:
              json.dump(payload, handle, ensure_ascii=True, indent=2)
          PY
          echo "server3_config_path=${config_path}" >> "${GITHUB_OUTPUT}"

      - name: Validate server-3 inputs
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('scripts/deploy_server3.sh') != '' }}
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "auth_security_group_id" "${RESOLVED_AUTH_SECURITY_GROUP_ID}"
          require "ami_id" "${RESOLVED_AMI_ID}"
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Deploy server-3 (if script present)
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('scripts/deploy_server3.sh') != '' }}
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ env.IMAGE_REGISTRY }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          AUTH_SECURITY_GROUP_ID: ${{ env.RESOLVED_AUTH_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          AUTH_INSTANCE_TYPE: ${{ env.RESOLVED_EDGE_INSTANCE_TYPE }}
          SERVER1_INTERNAL_ADDR: ${{ steps.resolve-server1.outputs.server1_internal_addr }}
          SERVER1_GATEWAY_URL: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
          SERVER3_CONFIG_PATH: ${{ steps.build-server3-config.outputs.server3_config_path }}
        run: bash scripts/deploy_server3.sh

      - name: Skip server-3 deploy
        if: ${{ env.RESOLVED_ENABLE_SERVER3 != 'true' }}
        run: echo "::notice::server-3 deploy disabled; skipping."

      - name: Skip server-3 deploy (script missing)
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('scripts/deploy_server3.sh') == '' }}
        run: echo "::warning::scripts/deploy_server3.sh not found; skipping server-3 deploy."

  stage-b:
    name: Stage B (server-2 + server-4)
    needs: stage-a
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      RESOLVED_AWS_REGION: ${{ inputs.aws_region != '' && inputs.aws_region || vars.OPENPCC_AWS_REGION || 'us-east-1' }}
      RESOLVED_SUBNET_ID: ${{ inputs.subnet_id != '' && inputs.subnet_id || vars.OPENPCC_SUBNET_ID }}
      RESOLVED_COMPUTE_SECURITY_GROUP_ID: ${{ inputs.compute_security_group_id != '' && inputs.compute_security_group_id || vars.OPENPCC_COMPUTE_SECURITY_GROUP_ID }}
      RESOLVED_RELAY_SECURITY_GROUP_ID: ${{ inputs.relay_security_group_id != '' && inputs.relay_security_group_id || vars.OPENPCC_RELAY_SECURITY_GROUP_ID }}
      RESOLVED_INSTANCE_PROFILE_ARN: ${{ inputs.instance_profile_arn != '' && inputs.instance_profile_arn || vars.OPENPCC_INSTANCE_PROFILE_ARN }}
      RESOLVED_KEY_NAME: ${{ inputs.key_name != '' && inputs.key_name || vars.OPENPCC_KEY_NAME }}
      RESOLVED_AMI_ID: ${{ inputs.ami_id != '' && inputs.ami_id || vars.OPENPCC_AMI_ID }}
      RESOLVED_COMPUTE_INSTANCE_TYPE: ${{ inputs.compute_instance_type }}
      RESOLVED_EDGE_INSTANCE_TYPE: ${{ inputs.edge_instance_type }}
      RESOLVED_ENABLE_COMPUTE_MONITOR: ${{ inputs.enable_compute_monitor }}
      RESOLVED_COMPUTE_BOOT_BUILD_TAGS: ${{ inputs.enable_fake_attestation_for_server2 && 'include_fake_attestation' || '' }}
      RESOLVED_ENCLAVE_CPU_COUNT: ${{ inputs.enclave_cpu_count != '' && inputs.enclave_cpu_count || vars.OPENPCC_ENCLAVE_CPU_COUNT || '2' }}
      RESOLVED_ENCLAVE_MEMORY_MIB: ${{ inputs.enclave_memory_mib != '' && inputs.enclave_memory_mib || vars.OPENPCC_ENCLAVE_MEMORY_MIB || '2048' }}
      RESOLVED_ENCLAVE_CID: ${{ inputs.enclave_cid != '' && inputs.enclave_cid || vars.OPENPCC_ENCLAVE_CID || '16' }}
      RESOLVED_TPM_SIMULATOR_CMD_PORT: "2321"
      RESOLVED_TPM_SIMULATOR_PLATFORM_PORT: "2322"
      SERVER1_INTERNAL_ADDR: ${{ needs.stage-a.outputs.server1_internal_addr }}
      SERVER1_ROUTER_URL: ${{ needs.stage-a.outputs.server1_router_url }}
      SERVER1_GATEWAY_URL: ${{ needs.stage-a.outputs.server1_gateway_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate AWS_ROLE_ARN
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
        run: |
          set -euo pipefail
          if [ -z "${AWS_ROLE_ARN}" ]; then
            echo "::error::Missing GitHub Actions secret AWS_ROLE_ARN."
            echo "::error::Set AWS_ROLE_ARN to the IAM Role ARN for GitHub Actions OIDC."
            echo "::error::Do not use Instance Profile ARN here."
            echo "::error::AWS Console: IAM -> Roles -> <role> -> ARN"
            echo "::error::CLI: aws iam get-role --role-name <ROLE_NAME> --query Role.Arn --output text"
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.RESOLVED_AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        if: ${{ inputs.image_registry == '' && vars.OPENPCC_IMAGE_REGISTRY == '' }}
        uses: aws-actions/amazon-ecr-login@v2

      - name: Resolve image registry
        id: resolve-registry
        env:
          INPUT_IMAGE_REGISTRY: ${{ inputs.image_registry }}
          VAR_IMAGE_REGISTRY: ${{ vars.OPENPCC_IMAGE_REGISTRY }}
          PRIVATE_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          set -euo pipefail
          if [ -n "${INPUT_IMAGE_REGISTRY}" ]; then
            resolved="${INPUT_IMAGE_REGISTRY}"
          elif [ -n "${VAR_IMAGE_REGISTRY}" ]; then
            resolved="${VAR_IMAGE_REGISTRY}"
          else
            resolved="${PRIVATE_REGISTRY}"
          fi
          echo "IMAGE_REGISTRY=${resolved}" >> "$GITHUB_ENV"
          if [[ "${resolved}" == public.ecr.aws/* ]]; then
            echo "IMAGE_REGISTRY_IS_PUBLIC=true" >> "$GITHUB_ENV"
          else
            echo "IMAGE_REGISTRY_IS_PUBLIC=false" >> "$GITHUB_ENV"
          fi

      - name: Login to public ECR
        if: ${{ env.IMAGE_REGISTRY_IS_PUBLIC == 'true' }}
        run: |
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws

      - name: Ensure ECR repositories (server-2/4)
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          COMPUTE_IMAGE_NAME: openpcc-compute
          RELAY_IMAGE_NAME: ${{ env.SERVER4_IMAGE_NAME }}
        run: |
          set -euo pipefail
          IMAGE_REGISTRY_IS_PUBLIC="${IMAGE_REGISTRY_IS_PUBLIC:-false}"
          ensure_repo() {
            local name="$1"
            if [[ "${IMAGE_REGISTRY_IS_PUBLIC}" == "true" ]]; then
              local public_region="us-east-1"
              if ! aws ecr-public describe-repositories --region "${public_region}" --repository-names "${name}" >/dev/null 2>&1; then
                echo "Creating public ECR repository: ${name}"
                aws ecr-public create-repository --region "${public_region}" --repository-name "${name}" >/dev/null
              else
                echo "Public ECR repository exists: ${name}"
              fi
            else
              if ! aws ecr describe-repositories --region "${AWS_REGION}" --repository-names "${name}" >/dev/null 2>&1; then
                echo "Creating ECR repository: ${name}"
                aws ecr create-repository --region "${AWS_REGION}" --repository-name "${name}" >/dev/null
              else
                echo "ECR repository exists: ${name}"
              fi
            fi
          }
          ensure_repo "${COMPUTE_IMAGE_NAME}"
          ensure_repo "${RELAY_IMAGE_NAME}"

      - name: Validate stage B inputs
        run: |
          set -euo pipefail
          IMAGE_REGISTRY_IS_PUBLIC="${IMAGE_REGISTRY_IS_PUBLIC:-false}"
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "subnet_id" "${RESOLVED_SUBNET_ID}"
          require "compute_security_group_id" "${RESOLVED_COMPUTE_SECURITY_GROUP_ID}"
          require "server1_internal_addr" "${SERVER1_INTERNAL_ADDR}"
          require "server1_router_url" "${SERVER1_ROUTER_URL}"
          require "server1_gateway_url" "${SERVER1_GATEWAY_URL}"
          require "ami_id" "${RESOLVED_AMI_ID}"
          if [ -z "${RESOLVED_INSTANCE_PROFILE_ARN}" ] && [ "${IMAGE_REGISTRY_IS_PUBLIC}" != "true" ]; then
            echo "instance_profile_arn is empty; set image_registry to a public registry (public.ecr.aws/alias)." >&2
            missing=1
          fi
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Build server-2 image
        env:
          COMPONENT: server-2
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ env.IMAGE_REGISTRY }}
          COMPUTE_BOOT_BUILD_TAGS: ${{ env.RESOLVED_COMPUTE_BOOT_BUILD_TAGS }}
        run: bash scripts/build_pack.sh

      - name: Build server-4 image (if present)
        if: ${{ hashFiles('server-4/Dockerfile') != '' }}
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          REGISTRY: ${{ env.IMAGE_REGISTRY }}
          SERVER4_IMAGE_NAME: ${{ env.SERVER4_IMAGE_NAME }}
        run: |
          set -euo pipefail
          image="${REGISTRY}/${SERVER4_IMAGE_NAME}:${IMAGE_TAG}"
          echo "Building ${image} from server-4/Dockerfile"
          docker build -f server-4/Dockerfile -t "${image}" server-4
          docker push "${image}"

      - name: Skip server-4 build
        if: ${{ hashFiles('server-4/Dockerfile') == '' }}
        run: echo "::warning::server-4 Dockerfile not found; skipping build."

      - name: Validate server-4 inputs
        if: ${{ hashFiles('scripts/deploy_server4.sh') != '' }}
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "relay_security_group_id" "${RESOLVED_RELAY_SECURITY_GROUP_ID}"
          require "ami_id" "${RESOLVED_AMI_ID}"
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Deploy server-2
        env:
          COMPONENT: server-2
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ env.IMAGE_REGISTRY }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          COMPUTE_SECURITY_GROUP_ID: ${{ env.RESOLVED_COMPUTE_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          COMPUTE_INSTANCE_TYPE: ${{ env.RESOLVED_COMPUTE_INSTANCE_TYPE }}
          ENABLE_COMPUTE_MONITOR: ${{ env.RESOLVED_ENABLE_COMPUTE_MONITOR }}
          ROUTER_ADDRESS: ${{ env.SERVER1_ROUTER_URL }}
          ENCLAVE_CPU_COUNT: ${{ env.RESOLVED_ENCLAVE_CPU_COUNT }}
          ENCLAVE_MEMORY_MIB: ${{ env.RESOLVED_ENCLAVE_MEMORY_MIB }}
          ENCLAVE_CID: ${{ env.RESOLVED_ENCLAVE_CID }}
          TPM_SIMULATOR_CMD_PORT: ${{ env.RESOLVED_TPM_SIMULATOR_CMD_PORT }}
          TPM_SIMULATOR_PLATFORM_PORT: ${{ env.RESOLVED_TPM_SIMULATOR_PLATFORM_PORT }}
        run: bash scripts/deploy_server2.sh

      - name: Deploy server-4 (if script present)
        if: ${{ hashFiles('scripts/deploy_server4.sh') != '' }}
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ env.IMAGE_REGISTRY }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          RELAY_SECURITY_GROUP_ID: ${{ env.RESOLVED_RELAY_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          RELAY_INSTANCE_TYPE: ${{ env.RESOLVED_EDGE_INSTANCE_TYPE }}
          RELAY_UPSTREAM_GATEWAY_URL: ${{ env.SERVER1_GATEWAY_URL }}
          SERVER1_INTERNAL_ADDR: ${{ env.SERVER1_INTERNAL_ADDR }}
        run: bash scripts/deploy_server4.sh

      - name: Skip server-4 deploy
        if: ${{ hashFiles('scripts/deploy_server4.sh') == '' }}
        run: echo "::warning::scripts/deploy_server4.sh not found; skipping server-4 deploy."
