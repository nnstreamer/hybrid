# Objective: One-shot build/pack/deploy workflow for OpenPCC v0.002.
# - Stage A: build/pack/deploy server-1, then server-4, then server-3 (relay URL bootstrap).
# - Stage B: build/pack/deploy server-2 using server-1 address.
# - Image tag is derived from the commit SHA.
# - Compute EIF is built during server-2 deploy (no S3 input needed).
name: OpenPCC v0.002 One-shot Deploy

on:
  workflow_dispatch:
    inputs:
      aws_region:
        type: string
        description: AWS region
        default: ""
      subnet_id:
        type: string
        description: Subnet ID for instances
        default: ""
      router_security_group_id:
        type: string
        description: Security group ID for server-1 (router/gateway)
        default: ""
      compute_security_group_id:
        type: string
        description: Security group ID for server-2 (compute)
        default: ""
      auth_security_group_id:
        type: string
        description: Security group ID for server-3 (auth)
        default: ""
      relay_security_group_id:
        type: string
        description: Security group ID for server-4 (relay)
        default: ""
      instance_profile_arn:
        type: string
        description: Required IAM instance profile ARN for EC2
        default: ""
      image_registry:
        type: string
        description: Public ECR registry base (e.g., public.ecr.aws/alias)
        default: ""
      key_name:
        type: string
        description: Optional EC2 key pair name
        default: ""
      enable_server3:
        type: boolean
        description: Enable server-3 build/deploy
        default: true
      enable_server4:
        type: boolean
        description: Enable server-4 build/deploy
        default: true
      ami_id:
        type: string
        description: Base AMI ID (Ubuntu 22.04 recommended)
        default: ""
      compute_instance_type:
        type: string
        description: server-2 instance type (Nitro Enclaves enabled)
        default: "c6a.4xlarge"
      edge_instance_type:
        type: string
        description: server-1/3/4 instance type
        default: "t3.small"
      enable_compute_monitor:
        type: boolean
        description: Install compute monitor on server-2 (debug only)
        default: true
      enable_fake_attestation_for_server2:
        type: boolean
        description: Enable fake attestation for server-2 build (do not combine with real attestation for client)
        default: true
      enclave_cpu_count:
        type: string
        description: Enclave CPU count
        default: ""
      enclave_memory_mib:
        type: string
        description: Enclave memory (MiB)
        default: ""
      enclave_cid:
        type: string
        description: Enclave CID for VSOCK connections
        default: "16"
      enable_ohttp:
        type: boolean
        description: Enable server-3 to advertise relay URLs (requires relay URLs and seeds)
        default: false
      enable_real_attestation_for_client:
        type: boolean
        description: Enable real attestation policy for clients (do not combine with fake attestation for server-2)
        default: false

env:
  IMAGE_TAG: ${{ github.sha }}
  SERVER3_IMAGE_NAME: ${{ vars.OPENPCC_AUTH_IMAGE_NAME != '' && vars.OPENPCC_AUTH_IMAGE_NAME || 'openpcc-auth' }}
  SERVER4_IMAGE_NAME: ${{ vars.OPENPCC_RELAY_IMAGE_NAME != '' && vars.OPENPCC_RELAY_IMAGE_NAME || 'openpcc-relay' }}

jobs:
  stage-a:
    name: Stage A (server-1 + server-4 + server-3)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      server1_internal_addr: ${{ steps.resolve-server1.outputs.server1_internal_addr }}
      server1_router_url: ${{ steps.resolve-server1.outputs.server1_router_url }}
      server1_gateway_url: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
    env:
      RESOLVED_AWS_REGION: ${{ inputs.aws_region != '' && inputs.aws_region || vars.OPENPCC_AWS_REGION || 'us-east-1' }}
      RESOLVED_SUBNET_ID: ${{ inputs.subnet_id != '' && inputs.subnet_id || vars.OPENPCC_SUBNET_ID }}
      RESOLVED_ROUTER_SECURITY_GROUP_ID: ${{ inputs.router_security_group_id != '' && inputs.router_security_group_id || vars.OPENPCC_ROUTER_SECURITY_GROUP_ID }}
      RESOLVED_AUTH_SECURITY_GROUP_ID: ${{ inputs.auth_security_group_id != '' && inputs.auth_security_group_id || vars.OPENPCC_AUTH_SECURITY_GROUP_ID }}
      RESOLVED_INSTANCE_PROFILE_ARN: ${{ inputs.instance_profile_arn != '' && inputs.instance_profile_arn || vars.OPENPCC_INSTANCE_PROFILE_ARN }}
      RESOLVED_KEY_NAME: ${{ inputs.key_name != '' && inputs.key_name || vars.OPENPCC_KEY_NAME }}
      RESOLVED_ENABLE_SERVER3: ${{ inputs.enable_server3 }}
      RESOLVED_ENABLE_SERVER4: ${{ inputs.enable_server4 }}
      RESOLVED_AMI_ID: ${{ inputs.ami_id != '' && inputs.ami_id || vars.OPENPCC_AMI_ID }}
      RESOLVED_EDGE_INSTANCE_TYPE: ${{ inputs.edge_instance_type }}
      RESOLVED_GATEWAY_PORT: "3200"
      RESOLVED_OHTTP_SEEDS_SECRET_REF: ${{ vars.OPENPCC_OHTTP_SEEDS_SECRET_REF != '' && vars.OPENPCC_OHTTP_SEEDS_SECRET_REF || '' }}
      RESOLVED_ENABLE_OHTTP: ${{ inputs.enable_ohttp }}
      RESOLVED_ENABLE_REAL_ATTESTATION_FOR_CLIENT: ${{ inputs.enable_real_attestation_for_client }}
      RESOLVED_ENABLE_FAKE_ATTESTATION_FOR_SERVER2: ${{ inputs.enable_fake_attestation_for_server2 }}
      RESOLVED_RELAY_URLS_JSON: ${{ vars.OPENPCC_RELAY_URLS_JSON != '' && vars.OPENPCC_RELAY_URLS_JSON || '' }}
      RESOLVED_OHTTP_SEEDS_JSON: ${{ secrets.OPENPCC_OHTTP_SEEDS_JSON != '' && secrets.OPENPCC_OHTTP_SEEDS_JSON || vars.OPENPCC_OHTTP_SEEDS_JSON || '' }}
      RESOLVED_ATTESTATION_POLICY_ID: ${{ vars.OPENPCC_ATTESTATION_POLICY_ID != '' && vars.OPENPCC_ATTESTATION_POLICY_ID || '' }}
      RESOLVED_ATTESTATION_ALLOWED_JSON: ${{ secrets.OPENPCC_ATTESTATION_ALLOWED_JSON != '' && secrets.OPENPCC_ATTESTATION_ALLOWED_JSON || vars.OPENPCC_ATTESTATION_ALLOWED_JSON || '' }}
      RESOLVED_ATTESTATION_VERIFIER_HINTS_JSON: ${{ secrets.OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON != '' && secrets.OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON || vars.OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON || '' }}
      RESOLVED_RELAY_SECURITY_GROUP_ID: ${{ inputs.relay_security_group_id != '' && inputs.relay_security_group_id || vars.OPENPCC_RELAY_SECURITY_GROUP_ID }}
      RESOLVED_RELAY_EIP_ALLOCATION_ID: ${{ vars.OPENPCC_RELAY_EIP_ALLOCATION_ID != '' && vars.OPENPCC_RELAY_EIP_ALLOCATION_ID || '' }}
      RESOLVED_RELAY_EIP_AUTO_ALLOCATE: ${{ vars.OPENPCC_RELAY_EIP_AUTO_ALLOCATE != '' && vars.OPENPCC_RELAY_EIP_AUTO_ALLOCATE || 'false' }}
      RESOLVED_RELAY_ROUTE53_ZONE_ID: ${{ vars.OPENPCC_RELAY_ROUTE53_ZONE_ID != '' && vars.OPENPCC_RELAY_ROUTE53_ZONE_ID || '' }}
      RESOLVED_RELAY_ROUTE53_RECORD_NAME: ${{ vars.OPENPCC_RELAY_ROUTE53_RECORD_NAME != '' && vars.OPENPCC_RELAY_ROUTE53_RECORD_NAME || '' }}
      RESOLVED_RELAY_ROUTE53_TTL: ${{ vars.OPENPCC_RELAY_ROUTE53_TTL != '' && vars.OPENPCC_RELAY_ROUTE53_TTL || '60' }}
    steps:
      - name: Preflight validate config inputs
        env:
          ENABLE_SERVER3: ${{ env.RESOLVED_ENABLE_SERVER3 }}
          ENABLE_SERVER4: ${{ env.RESOLVED_ENABLE_SERVER4 }}
          ENABLE_OHTTP: ${{ env.RESOLVED_ENABLE_OHTTP }}
          ENABLE_REAL_ATTESTATION_FOR_CLIENT: ${{ env.RESOLVED_ENABLE_REAL_ATTESTATION_FOR_CLIENT }}
          ENABLE_FAKE_ATTESTATION_FOR_SERVER2: ${{ env.RESOLVED_ENABLE_FAKE_ATTESTATION_FOR_SERVER2 }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          ROUTER_SECURITY_GROUP_ID: ${{ env.RESOLVED_ROUTER_SECURITY_GROUP_ID }}
          COMPUTE_SECURITY_GROUP_ID: ${{ inputs.compute_security_group_id != '' && inputs.compute_security_group_id || vars.OPENPCC_COMPUTE_SECURITY_GROUP_ID }}
          AUTH_SECURITY_GROUP_ID: ${{ env.RESOLVED_AUTH_SECURITY_GROUP_ID }}
          RELAY_SECURITY_GROUP_ID: ${{ env.RESOLVED_RELAY_SECURITY_GROUP_ID }}
          RELAY_EIP_ALLOCATION_ID: ${{ env.RESOLVED_RELAY_EIP_ALLOCATION_ID }}
          RELAY_EIP_AUTO_ALLOCATE: ${{ env.RESOLVED_RELAY_EIP_AUTO_ALLOCATE }}
          RELAY_ROUTE53_ZONE_ID: ${{ env.RESOLVED_RELAY_ROUTE53_ZONE_ID }}
          RELAY_ROUTE53_RECORD_NAME: ${{ env.RESOLVED_RELAY_ROUTE53_RECORD_NAME }}
          RELAY_ROUTE53_TTL: ${{ env.RESOLVED_RELAY_ROUTE53_TTL }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          IMAGE_REGISTRY_INPUT: ${{ inputs.image_registry }}
          IMAGE_REGISTRY_VAR: ${{ vars.OPENPCC_IMAGE_REGISTRY }}
          RELAY_URLS_JSON: ${{ env.RESOLVED_RELAY_URLS_JSON }}
          OHTTP_SEEDS_JSON: ${{ env.RESOLVED_OHTTP_SEEDS_JSON }}
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
          ATTESTATION_POLICY_ID: ${{ env.RESOLVED_ATTESTATION_POLICY_ID }}
          ATTESTATION_ALLOWED_JSON: ${{ env.RESOLVED_ATTESTATION_ALLOWED_JSON }}
          ATTESTATION_VERIFIER_HINTS_JSON: ${{ env.RESOLVED_ATTESTATION_VERIFIER_HINTS_JSON }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json
          import os
          import sys

          def parse_bool(value, name, default):
              if value is None or str(value).strip() == "":
                  return default
              lowered = str(value).strip().lower()
              if lowered in ("true", "1", "yes", "y"):
                  return True
              if lowered in ("false", "0", "no", "n"):
                  return False
              raise SystemExit(f"{name} must be true/false (got '{value}')")

          missing = []

          def require(name, value, hint):
              if value is None or str(value).strip() == "":
                  missing.append(f"{name} ({hint})")

          def parse_json(name, raw, expected_type):
              try:
                  data = json.loads(raw)
              except json.JSONDecodeError as exc:
                  raise SystemExit(f"{name} must be valid JSON: {exc}") from exc
              if not isinstance(data, expected_type):
                  raise SystemExit(f"{name} must be a {expected_type.__name__} JSON value")
              return data

          enable_server3 = parse_bool(os.getenv("ENABLE_SERVER3"), "ENABLE_SERVER3", True)
          enable_server4 = parse_bool(os.getenv("ENABLE_SERVER4"), "ENABLE_SERVER4", True)
          enable_ohttp = parse_bool(os.getenv("ENABLE_OHTTP"), "ENABLE_OHTTP", False)
          enable_real = parse_bool(
              os.getenv("ENABLE_REAL_ATTESTATION_FOR_CLIENT"),
              "ENABLE_REAL_ATTESTATION_FOR_CLIENT",
              False,
          )
          enable_fake = parse_bool(
              os.getenv("ENABLE_FAKE_ATTESTATION_FOR_SERVER2"),
              "ENABLE_FAKE_ATTESTATION_FOR_SERVER2",
              False,
          )

          if enable_real and enable_fake:
              raise SystemExit(
                  "enable_fake_attestation_for_server2=true is not consistent with "
                  "enable_real_attestation_for_client=true. Disable one of them."
              )

          image_registry = os.getenv("IMAGE_REGISTRY_INPUT", "").strip() or os.getenv("IMAGE_REGISTRY_VAR", "").strip()
          image_registry_is_public = image_registry.startswith("public.ecr.aws/")

          require("subnet_id", os.getenv("SUBNET_ID"), "workflow input or OPENPCC_SUBNET_ID")
          require(
              "router_security_group_id",
              os.getenv("ROUTER_SECURITY_GROUP_ID"),
              "workflow input or OPENPCC_ROUTER_SECURITY_GROUP_ID",
          )
          require(
              "compute_security_group_id",
              os.getenv("COMPUTE_SECURITY_GROUP_ID"),
              "workflow input or OPENPCC_COMPUTE_SECURITY_GROUP_ID",
          )
          require("ami_id", os.getenv("AMI_ID"), "workflow input or OPENPCC_AMI_ID")
          if enable_server3:
              require(
                  "auth_security_group_id",
                  os.getenv("AUTH_SECURITY_GROUP_ID"),
                  "workflow input or OPENPCC_AUTH_SECURITY_GROUP_ID",
              )
          if enable_server4:
              require(
                  "relay_security_group_id",
                  os.getenv("RELAY_SECURITY_GROUP_ID"),
                  "workflow input or OPENPCC_RELAY_SECURITY_GROUP_ID",
              )
          if not image_registry_is_public:
              if not os.getenv("INSTANCE_PROFILE_ARN", "").strip():
                  missing.append(
                      "instance_profile_arn (required unless image_registry is public.ecr.aws/...)"
                  )

          if enable_server3 and enable_ohttp:
              relay_raw = os.getenv("RELAY_URLS_JSON", "")
              seeds_raw = os.getenv("OHTTP_SEEDS_JSON", "")
              seeds_ref = os.getenv("OHTTP_SEEDS_SECRET_REF", "")
              if relay_raw.strip():
                  relay = parse_json("OPENPCC_RELAY_URLS_JSON", relay_raw, list)
                  if not relay:
                      raise SystemExit("OPENPCC_RELAY_URLS_JSON must be a non-empty list")
                  for idx, item in enumerate(relay):
                      if not isinstance(item, str) or not item.strip():
                          raise SystemExit(
                              f"OPENPCC_RELAY_URLS_JSON[{idx}] must be a non-empty string"
                          )
              elif not enable_server4:
                  require(
                      "OPENPCC_RELAY_URLS_JSON",
                      relay_raw,
                      "repo variable (required when enable_ohttp=true and enable_server4=false)",
                  )
              require(
                  "OPENPCC_OHTTP_SEEDS_JSON",
                  seeds_raw,
                  "repo variable/secret (required when enable_ohttp=true)",
              )
              seeds = parse_json("OPENPCC_OHTTP_SEEDS_JSON", seeds_raw, list)
              if not seeds:
                  raise SystemExit("OPENPCC_OHTTP_SEEDS_JSON must be a non-empty list")
              for idx, seed in enumerate(seeds):
                  if not isinstance(seed, dict):
                      raise SystemExit(f"OPENPCC_OHTTP_SEEDS_JSON[{idx}] must be an object")
                  for key in ("key_id", "seed_hex", "active_from", "active_until"):
                      value = seed.get(key)
                      if not isinstance(value, str) or not value.strip():
                          raise SystemExit(
                              f"OPENPCC_OHTTP_SEEDS_JSON[{idx}].{key} must be a non-empty string"
                          )
              require(
                  "OPENPCC_OHTTP_SEEDS_SECRET_REF",
                  seeds_ref,
                  "repo variable (required when enable_ohttp=true)",
              )

          att_policy_id = os.getenv("ATTESTATION_POLICY_ID", "")
          allowed_raw = os.getenv("ATTESTATION_ALLOWED_JSON", "")
          hints_raw = os.getenv("ATTESTATION_VERIFIER_HINTS_JSON", "")
          if enable_server3 and enable_real:
              require(
                  "OPENPCC_ATTESTATION_POLICY_ID",
                  att_policy_id,
                  "repo variable (required when enable_real_attestation_for_client=true)",
              )
              require(
                  "OPENPCC_ATTESTATION_ALLOWED_JSON",
                  allowed_raw,
                  "repo variable/secret (required when enable_real_attestation_for_client=true)",
              )
              require(
                  "OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON",
                  hints_raw,
                  "repo variable/secret (required when enable_real_attestation_for_client=true)",
              )
              parse_json("OPENPCC_ATTESTATION_ALLOWED_JSON", allowed_raw, dict)
              parse_json("OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON", hints_raw, dict)
          elif enable_server3:
              if (
                  str(att_policy_id).strip()
                  or str(allowed_raw).strip()
                  or str(hints_raw).strip()
              ):
                  raise SystemExit(
                      "attestation inputs provided but enable_real_attestation_for_client=false"
                  )
          if missing:
              print("Missing required inputs/vars/secrets:")
              for item in missing:
                  print(f"- {item}")
              raise SystemExit(1)
          PY

      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate AWS_ROLE_ARN
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
        run: |
          set -euo pipefail
          if [ -z "${AWS_ROLE_ARN}" ]; then
            echo "::error::Missing GitHub Actions secret AWS_ROLE_ARN."
            echo "::error::Set AWS_ROLE_ARN to the IAM Role ARN for GitHub Actions OIDC."
            echo "::error::Do not use Instance Profile ARN here."
            echo "::error::AWS Console: IAM -> Roles -> <role> -> ARN"
            echo "::error::CLI: aws iam get-role --role-name <ROLE_NAME> --query Role.Arn --output text"
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.RESOLVED_AWS_REGION }}

      - name: Resolve image registry
        id: resolve-registry
        env:
          INPUT_IMAGE_REGISTRY: ${{ inputs.image_registry }}
          VAR_IMAGE_REGISTRY: ${{ vars.OPENPCC_IMAGE_REGISTRY }}
        run: |
          set -euo pipefail
          if [ -n "${INPUT_IMAGE_REGISTRY}" ]; then
            resolved="${INPUT_IMAGE_REGISTRY}"
          elif [ -n "${VAR_IMAGE_REGISTRY}" ]; then
            resolved="${VAR_IMAGE_REGISTRY}"
          else
            echo "Missing image_registry. Set workflow input or OPENPCC_IMAGE_REGISTRY." >&2
            exit 1
          fi
          if [[ "${resolved}" != public.ecr.aws/* ]]; then
            echo "image_registry must be a public ECR registry (public.ecr.aws/alias)." >&2
            exit 1
          fi
          echo "IMAGE_REGISTRY=${resolved}" >> "$GITHUB_ENV"

      - name: Login to public ECR
        run: |
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws

      - name: Ensure ECR repositories (server-1/3/4)
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          ROUTER_IMAGE_NAME: openpcc-router
          AUTH_IMAGE_NAME: ${{ env.SERVER3_IMAGE_NAME }}
          ENABLE_SERVER3: ${{ env.RESOLVED_ENABLE_SERVER3 }}
          RELAY_IMAGE_NAME: ${{ env.SERVER4_IMAGE_NAME }}
          ENABLE_SERVER4: ${{ env.RESOLVED_ENABLE_SERVER4 }}
        run: |
          set -euo pipefail
          ensure_repo() {
            local name="$1"
            local public_region="us-east-1"
            if ! aws ecr-public describe-repositories --region "${public_region}" --repository-names "${name}" >/dev/null 2>&1; then
              echo "Creating public ECR repository: ${name}"
              aws ecr-public create-repository --region "${public_region}" --repository-name "${name}" >/dev/null
            else
              echo "Public ECR repository exists: ${name}"
            fi
          }
          ensure_repo "${ROUTER_IMAGE_NAME}"
          if [[ "${ENABLE_SERVER3}" == "true" ]]; then
            ensure_repo "${AUTH_IMAGE_NAME}"
          else
            echo "server-3 disabled; skipping auth repository creation."
          fi
          if [[ "${ENABLE_SERVER4}" == "true" ]]; then
            ensure_repo "${RELAY_IMAGE_NAME}"
          else
            echo "server-4 disabled; skipping relay repository creation."
          fi

      - name: Validate stage A inputs
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "subnet_id" "${RESOLVED_SUBNET_ID}"
          require "router_security_group_id" "${RESOLVED_ROUTER_SECURITY_GROUP_ID}"
          require "ami_id" "${RESOLVED_AMI_ID}"
          require "image_registry" "${IMAGE_REGISTRY}"
          if [[ "${IMAGE_REGISTRY}" != public.ecr.aws/* ]]; then
            require "instance_profile_arn" "${RESOLVED_INSTANCE_PROFILE_ARN}"
          fi
          if [[ "${RESOLVED_ENABLE_SERVER4}" == "true" ]]; then
            require "relay_security_group_id" "${RESOLVED_RELAY_SECURITY_GROUP_ID}"
          fi
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Build server-1 image
        env:
          COMPONENT: server-1
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ env.IMAGE_REGISTRY }}
        run: bash scripts/build_pack.sh

      - name: Build server-4 image (if enabled)
        if: ${{ env.RESOLVED_ENABLE_SERVER4 == 'true' && hashFiles('server-4/Dockerfile') != '' }}
        env:
          COMPONENT: server-4
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ env.IMAGE_REGISTRY }}
          RELAY_IMAGE_NAME: ${{ env.SERVER4_IMAGE_NAME }}
        run: bash scripts/build_pack.sh

      - name: Skip server-4 build
        if: ${{ env.RESOLVED_ENABLE_SERVER4 != 'true' }}
        run: echo "::notice::server-4 build disabled; skipping."

      - name: Skip server-4 build (Dockerfile missing)
        if: ${{ env.RESOLVED_ENABLE_SERVER4 == 'true' && hashFiles('server-4/Dockerfile') == '' }}
        run: echo "::warning::server-4 Dockerfile not found; skipping build."

      - name: Build server-3 image (if present)
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('server-3/Dockerfile') != '' }}
        env:
          COMPONENT: server-3
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ env.IMAGE_REGISTRY }}
          AUTH_IMAGE_NAME: ${{ env.SERVER3_IMAGE_NAME }}
        run: bash scripts/build_pack.sh

      - name: Skip server-3 build
        if: ${{ env.RESOLVED_ENABLE_SERVER3 != 'true' }}
        run: echo "::notice::server-3 build disabled; skipping."

      - name: Skip server-3 build (Dockerfile missing)
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('server-3/Dockerfile') == '' }}
        run: echo "::warning::server-3 Dockerfile not found; skipping build."

      - name: Deploy server-1
        env:
          COMPONENT: server-1
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ env.IMAGE_REGISTRY }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          ROUTER_SECURITY_GROUP_ID: ${{ env.RESOLVED_ROUTER_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          ROUTER_INSTANCE_TYPE: ${{ env.RESOLVED_EDGE_INSTANCE_TYPE }}
          # NOTE: Used for gateway seed sync when provided.
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
          OHTTP_SEEDS_JSON: ${{ env.RESOLVED_OHTTP_SEEDS_JSON }}
        run: bash scripts/deploy_server1.sh

      - name: Resolve server-1 address
        id: resolve-server1
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          GATEWAY_PORT: "3200"
        run: |
          set -euo pipefail
          instance_id=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --filters "Name=tag:Name,Values=openpcc-router" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId | [0]" \
            --output text)
          if [ -z "${instance_id}" ] || [ "${instance_id}" = "None" ]; then
            echo "Failed to find running server-1 instance (tag Name=openpcc-router)." >&2
            exit 1
          fi
          private_ip=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --instance-ids "${instance_id}" \
            --query "Reservations[0].Instances[0].PrivateIpAddress" \
            --output text)
          if [ -z "${private_ip}" ] || [ "${private_ip}" = "None" ]; then
            echo "Failed to resolve server-1 private IP." >&2
            exit 1
          fi
          # Router port is fixed at 3600. Gateway port is configurable.
          router_url="http://${private_ip}:3600"
          gateway_url="http://${private_ip}:${GATEWAY_PORT}"
          echo "server1_internal_addr=${private_ip}" >> "${GITHUB_OUTPUT}"
          echo "server1_router_url=${router_url}" >> "${GITHUB_OUTPUT}"
          echo "server1_gateway_url=${gateway_url}" >> "${GITHUB_OUTPUT}"

      - name: Validate server-4 inputs
        if: ${{ env.RESOLVED_ENABLE_SERVER4 == 'true' && hashFiles('scripts/deploy_server4.sh') != '' }}
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "relay_security_group_id" "${RESOLVED_RELAY_SECURITY_GROUP_ID}"
          require "ami_id" "${RESOLVED_AMI_ID}"
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Deploy server-4 (if script present)
        if: ${{ env.RESOLVED_ENABLE_SERVER4 == 'true' && hashFiles('scripts/deploy_server4.sh') != '' }}
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ env.IMAGE_REGISTRY }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          RELAY_SECURITY_GROUP_ID: ${{ env.RESOLVED_RELAY_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          RELAY_INSTANCE_TYPE: ${{ env.RESOLVED_EDGE_INSTANCE_TYPE }}
          RELAY_UPSTREAM_GATEWAY_URL: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
          SERVER1_INTERNAL_ADDR: ${{ steps.resolve-server1.outputs.server1_internal_addr }}
        run: bash scripts/deploy_server4.sh

      - name: Resolve server-4 instance
        id: resolve-server4-instance
        if: ${{ env.RESOLVED_ENABLE_SERVER4 == 'true' && hashFiles('scripts/deploy_server4.sh') != '' }}
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
        run: |
          set -euo pipefail
          instance_id=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --filters "Name=tag:Name,Values=openpcc-relay" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId | [0]" \
            --output text)
          if [ -z "${instance_id}" ] || [ "${instance_id}" = "None" ]; then
            echo "Failed to find running server-4 instance (tag Name=openpcc-relay)." >&2
            exit 1
          fi
          private_ip=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --instance-ids "${instance_id}" \
            --query "Reservations[0].Instances[0].PrivateIpAddress" \
            --output text)
          public_ip=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --instance-ids "${instance_id}" \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)
          if [ -z "${private_ip}" ] || [ "${private_ip}" = "None" ]; then
            echo "Failed to resolve server-4 private IP address." >&2
            exit 1
          fi
          if [ -z "${public_ip}" ] || [ "${public_ip}" = "None" ]; then
            public_ip=""
          fi
          echo "server4_instance_id=${instance_id}" >> "${GITHUB_OUTPUT}"
          echo "server4_private_ip=${private_ip}" >> "${GITHUB_OUTPUT}"
          echo "server4_public_ip=${public_ip}" >> "${GITHUB_OUTPUT}"

      - name: Assign relay EIP (optional)
        id: assign-relay-eip
        if: ${{ env.RESOLVED_ENABLE_SERVER4 == 'true' && hashFiles('scripts/deploy_server4.sh') != '' }}
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          RELAY_EIP_ALLOCATION_ID: ${{ env.RESOLVED_RELAY_EIP_ALLOCATION_ID }}
          RELAY_EIP_AUTO_ALLOCATE: ${{ env.RESOLVED_RELAY_EIP_AUTO_ALLOCATE }}
          SERVER4_INSTANCE_ID: ${{ steps.resolve-server4-instance.outputs.server4_instance_id }}
        run: |
          set -euo pipefail
          if [[ -z "${SERVER4_INSTANCE_ID}" ]]; then
            echo "server-4 instance id missing; cannot associate EIP." >&2
            exit 1
          fi
          allocation_id="${RELAY_EIP_ALLOCATION_ID}"
          if [[ -z "${allocation_id}" ]]; then
            if [[ "${RELAY_EIP_AUTO_ALLOCATE}" == "true" ]]; then
              allocation_id=$(aws ec2 allocate-address --region "${AWS_REGION}" --domain vpc \
                --query "AllocationId" --output text)
              if [[ -z "${allocation_id}" || "${allocation_id}" == "None" ]]; then
                echo "Failed to allocate relay EIP." >&2
                exit 1
              fi
              aws ec2 create-tags --region "${AWS_REGION}" --resources "${allocation_id}" \
                --tags Key=Name,Value=openpcc-relay-eip >/dev/null
              echo "Allocated relay EIP: ${allocation_id}"
            else
              echo "Relay EIP not configured; skipping EIP association."
              exit 0
            fi
          fi
          aws ec2 associate-address --region "${AWS_REGION}" \
            --instance-id "${SERVER4_INSTANCE_ID}" \
            --allocation-id "${allocation_id}" \
            --allow-reassociation >/dev/null
          eip_public_ip=$(aws ec2 describe-addresses --region "${AWS_REGION}" \
            --allocation-ids "${allocation_id}" \
            --query "Addresses[0].PublicIp" --output text)
          if [[ -z "${eip_public_ip}" || "${eip_public_ip}" == "None" ]]; then
            echo "Failed to resolve relay EIP public IP." >&2
            exit 1
          fi
          echo "relay_eip_allocation_id=${allocation_id}" >> "${GITHUB_OUTPUT}"
          echo "relay_eip_public_ip=${eip_public_ip}" >> "${GITHUB_OUTPUT}"

      - name: Update relay Route53 (optional)
        if: ${{ env.RESOLVED_ENABLE_SERVER4 == 'true' && hashFiles('scripts/deploy_server4.sh') != '' && env.RESOLVED_RELAY_ROUTE53_ZONE_ID != '' && env.RESOLVED_RELAY_ROUTE53_RECORD_NAME != '' }}
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          RELAY_ROUTE53_ZONE_ID: ${{ env.RESOLVED_RELAY_ROUTE53_ZONE_ID }}
          RELAY_ROUTE53_RECORD_NAME: ${{ env.RESOLVED_RELAY_ROUTE53_RECORD_NAME }}
          RELAY_ROUTE53_TTL: ${{ env.RESOLVED_RELAY_ROUTE53_TTL }}
          RELAY_EIP_PUBLIC_IP: ${{ steps.assign-relay-eip.outputs.relay_eip_public_ip }}
          SERVER4_PUBLIC_IP: ${{ steps.resolve-server4-instance.outputs.server4_public_ip }}
        run: |
          set -euo pipefail
          record_name="${RELAY_ROUTE53_RECORD_NAME}"
          if [[ "${record_name}" != *.* ]]; then
            echo "Route53 record name looks invalid: ${record_name}" >&2
            exit 1
          fi
          if [[ "${record_name}" != *"." ]]; then
            record_name="${record_name}."
          fi
          ip="${RELAY_EIP_PUBLIC_IP}"
          if [[ -z "${ip}" ]]; then
            ip="${SERVER4_PUBLIC_IP}"
          fi
          if [[ -z "${ip}" ]]; then
            echo "No relay public IP available for Route53 update." >&2
            exit 1
          fi
          ttl="${RELAY_ROUTE53_TTL:-60}"
          cat > "${RUNNER_TEMP}/relay-route53.json" <<EOF
          {
            "Comment": "OpenPCC relay record",
            "Changes": [
              {
                "Action": "UPSERT",
                "ResourceRecordSet": {
                  "Name": "${record_name}",
                  "Type": "A",
                  "TTL": ${ttl},
                  "ResourceRecords": [
                    { "Value": "${ip}" }
                  ]
                }
              }
            ]
          }
          EOF
          aws route53 change-resource-record-sets \
            --hosted-zone-id "${RELAY_ROUTE53_ZONE_ID}" \
            --change-batch "file://${RUNNER_TEMP}/relay-route53.json"

      - name: Resolve server-4 relay URL
        id: resolve-server4
        if: ${{ env.RESOLVED_ENABLE_SERVER4 == 'true' && hashFiles('scripts/deploy_server4.sh') != '' }}
        env:
          RELAY_ROUTE53_RECORD_NAME: ${{ env.RESOLVED_RELAY_ROUTE53_RECORD_NAME }}
          RELAY_EIP_PUBLIC_IP: ${{ steps.assign-relay-eip.outputs.relay_eip_public_ip }}
          SERVER4_PUBLIC_IP: ${{ steps.resolve-server4-instance.outputs.server4_public_ip }}
          SERVER4_PRIVATE_IP: ${{ steps.resolve-server4-instance.outputs.server4_private_ip }}
        run: |
          set -euo pipefail
          if [[ -n "${RELAY_ROUTE53_RECORD_NAME}" ]]; then
            record_name="${RELAY_ROUTE53_RECORD_NAME}"
            record_name="${record_name%.}"
            relay_url="http://${record_name}:3100"
            echo "server4_relay_url=${relay_url}" >> "${GITHUB_OUTPUT}"
            exit 0
          fi
          if [[ -n "${RELAY_EIP_PUBLIC_IP}" ]]; then
            relay_url="http://${RELAY_EIP_PUBLIC_IP}:3100"
            echo "server4_relay_url=${relay_url}" >> "${GITHUB_OUTPUT}"
            exit 0
          fi
          if [[ -n "${SERVER4_PUBLIC_IP}" ]]; then
            relay_url="http://${SERVER4_PUBLIC_IP}:3100"
            echo "server4_relay_url=${relay_url}" >> "${GITHUB_OUTPUT}"
            exit 0
          fi
          if [[ -n "${SERVER4_PRIVATE_IP}" ]]; then
            echo "::warning::server-4 public IP missing; using private IP for relay URL."
            relay_url="http://${SERVER4_PRIVATE_IP}:3100"
            echo "server4_relay_url=${relay_url}" >> "${GITHUB_OUTPUT}"
            exit 0
          fi
          echo "Failed to resolve server-4 relay URL." >&2
          exit 1

      - name: Skip server-4 deploy
        if: ${{ env.RESOLVED_ENABLE_SERVER4 != 'true' }}
        run: echo "::notice::server-4 deploy disabled; skipping."

      - name: Skip server-4 deploy (script missing)
        if: ${{ env.RESOLVED_ENABLE_SERVER4 == 'true' && hashFiles('scripts/deploy_server4.sh') == '' }}
        run: echo "::warning::scripts/deploy_server4.sh not found; skipping server-4 deploy."

      - name: Resolve relay URLs for server-3
        id: resolve-relay-urls
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' }}
        env:
          ENABLE_OHTTP: ${{ env.RESOLVED_ENABLE_OHTTP }}
          ENABLE_SERVER4: ${{ env.RESOLVED_ENABLE_SERVER4 }}
          RELAY_URLS_JSON_INPUT: ${{ env.RESOLVED_RELAY_URLS_JSON }}
          SERVER4_RELAY_URL: ${{ steps.resolve-server4.outputs.server4_relay_url }}
        run: |
          set -euo pipefail
          if [[ "${ENABLE_OHTTP}" != "true" ]]; then
            echo "relay_urls_json=" >> "${GITHUB_OUTPUT}"
            exit 0
          fi
          if [[ -n "${RELAY_URLS_JSON_INPUT}" ]]; then
            echo "relay_urls_json=${RELAY_URLS_JSON_INPUT}" >> "${GITHUB_OUTPUT}"
            exit 0
          fi
          if [[ "${ENABLE_SERVER4}" == "true" ]]; then
            if [[ -z "${SERVER4_RELAY_URL}" ]]; then
              echo "server-4 relay URL missing; cannot enable oHTTP." >&2
              exit 1
            fi
            printf 'relay_urls_json=["%s"]\n' "${SERVER4_RELAY_URL}" >> "${GITHUB_OUTPUT}"
            exit 0
          fi
          echo "Missing relay URLs: provide OPENPCC_RELAY_URLS_JSON or enable server-4." >&2
          exit 1

      - name: Build server-3 config
        id: build-server3-config
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('scripts/deploy_server3.sh') != '' }}
        env:
          ENABLE_OHTTP: ${{ env.RESOLVED_ENABLE_OHTTP }}
          ENABLE_REAL_ATTESTATION_FOR_CLIENT: ${{ env.RESOLVED_ENABLE_REAL_ATTESTATION_FOR_CLIENT }}
          ENABLE_FAKE_ATTESTATION_FOR_SERVER2: ${{ env.RESOLVED_ENABLE_FAKE_ATTESTATION_FOR_SERVER2 }}
          RELAY_URLS_JSON: ${{ steps.resolve-relay-urls.outputs.relay_urls_json }}
          OHTTP_SEEDS_JSON: ${{ env.RESOLVED_OHTTP_SEEDS_JSON }}
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
          ATTESTATION_POLICY_ID: ${{ env.RESOLVED_ATTESTATION_POLICY_ID }}
          ATTESTATION_ALLOWED_JSON: ${{ env.RESOLVED_ATTESTATION_ALLOWED_JSON }}
          ATTESTATION_VERIFIER_HINTS_JSON: ${{ env.RESOLVED_ATTESTATION_VERIFIER_HINTS_JSON }}
          SERVER1_ROUTER_URL: ${{ steps.resolve-server1.outputs.server1_router_url }}
          SERVER1_GATEWAY_URL: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
        run: |
          set -euo pipefail
          config_path="${RUNNER_TEMP}/server-3.config.json"
          python3 - <<'PY' "${config_path}"
          import json
          import os
          import sys

          def parse_bool(value, name, default):
              if value is None or value.strip() == "":
                  return default
              lowered = value.strip().lower()
              if lowered in ("true", "1", "yes", "y"):
                  return True
              if lowered in ("false", "0", "no", "n"):
                  return False
              raise SystemExit(f"{name} must be true/false (got '{value}')")

          def parse_json(raw, name, required, expected_type):
              if raw.strip() == "":
                  if required:
                      raise SystemExit(f"{name} is required")
                  return expected_type()
              try:
                  data = json.loads(raw)
              except json.JSONDecodeError as exc:
                  raise SystemExit(f"{name} must be valid JSON: {exc}") from exc
              if not isinstance(data, expected_type):
                  raise SystemExit(f"{name} must be a {expected_type.__name__} JSON value")
              return data

          def ensure_non_empty_list(values, name):
              if not values:
                  raise SystemExit(f"{name} must be a non-empty list")
              for idx, item in enumerate(values):
                  if not isinstance(item, str) or not item.strip():
                      raise SystemExit(f"{name}[{idx}] must be a non-empty string")

          enable_ohttp = parse_bool(os.getenv("ENABLE_OHTTP"), "ENABLE_OHTTP", True)
          enable_real_attestation_for_client = parse_bool(
              os.getenv("ENABLE_REAL_ATTESTATION_FOR_CLIENT"),
              "ENABLE_REAL_ATTESTATION_FOR_CLIENT",
              True,
          )
          enable_fake_attestation_for_server2 = parse_bool(
              os.getenv("ENABLE_FAKE_ATTESTATION_FOR_SERVER2"),
              "ENABLE_FAKE_ATTESTATION_FOR_SERVER2",
              False,
          )

          if enable_fake_attestation_for_server2 and enable_real_attestation_for_client:
              raise SystemExit(
                  "enable_fake_attestation_for_server2=true is not consistent with "
                  "enable_real_attestation_for_client=true. Disable one of them."
              )

          server1_router_url = os.getenv("SERVER1_ROUTER_URL", "").strip()
          server1_gateway_url = os.getenv("SERVER1_GATEWAY_URL", "").strip()
          relay_urls_raw = os.getenv("RELAY_URLS_JSON", "")
          seeds_raw = os.getenv("OHTTP_SEEDS_JSON", "")
          seeds_secret_ref = os.getenv("OHTTP_SEEDS_SECRET_REF", "").strip()

          if enable_ohttp:
              if not server1_router_url or not server1_gateway_url:
                  raise SystemExit("SERVER1_ROUTER_URL and SERVER1_GATEWAY_URL are required for oHTTP")
              relay_urls = parse_json(relay_urls_raw, "relay_urls_json", True, list)
              ensure_non_empty_list(relay_urls, "relay_urls_json")
              seeds = parse_json(seeds_raw, "ohttp_seeds_json", True, list)
              if not seeds:
                  raise SystemExit("ohttp_seeds_json must be a non-empty list")
              if not seeds_secret_ref:
                  raise SystemExit("ohttp_seeds_secret_ref is required when oHTTP is enabled")
              seen_ids = set()
              for idx, seed in enumerate(seeds):
                  if not isinstance(seed, dict):
                      raise SystemExit(f"ohttp_seeds_json[{idx}] must be an object")
                  for key in ("key_id", "seed_hex", "active_from", "active_until"):
                      value = seed.get(key)
                      if not isinstance(value, str) or not value.strip():
                          raise SystemExit(f"ohttp_seeds_json[{idx}].{key} must be a non-empty string")
                  key_id = seed["key_id"]
                  if key_id in seen_ids:
                      raise SystemExit(f"ohttp_seeds_json[{idx}].key_id is duplicated: {key_id}")
                  seen_ids.add(key_id)
          else:
              if relay_urls_raw.strip() or seeds_raw.strip() or seeds_secret_ref:
                  raise SystemExit("oHTTP inputs provided but enable_ohttp=false")
              relay_urls = []
              seeds = []

          att_policy_id = os.getenv("ATTESTATION_POLICY_ID", "").strip()
          allowed_raw = os.getenv("ATTESTATION_ALLOWED_JSON", "")
          verifier_hints_raw = os.getenv("ATTESTATION_VERIFIER_HINTS_JSON", "")

          if enable_real_attestation_for_client:
              if not att_policy_id:
                  raise SystemExit(
                      "attestation_policy_id is required when real attestation for client is enabled"
                  )
              allowed = parse_json(allowed_raw, "attestation_allowed_json", False, dict)
              verifier_hints = parse_json(
                  verifier_hints_raw, "attestation_verifier_hints_json", False, dict
              )
          else:
              if att_policy_id or allowed_raw.strip() or verifier_hints_raw.strip():
                  raise SystemExit(
                      "attestation inputs provided but enable_real_attestation_for_client=false"
                  )
              allowed = {}
              verifier_hints = {}

          payload = {
              "version": "0.002",
              "features": {
                  "ohttp": enable_ohttp,
                  "real_attestation": enable_real_attestation_for_client,
              },
          }

          if enable_ohttp:
              payload.update(
                  {
                      "relay_urls": relay_urls,
                      "gateway_url": server1_gateway_url,
                      "router_url": server1_router_url,
                      "ohttp_seeds": seeds,
                  }
              )

          if enable_real_attestation_for_client:
              attestation = {
                  "policy_id": att_policy_id,
              }
              if allowed:
                  attestation["allowed"] = allowed
              if verifier_hints:
                  attestation["verifier_hints"] = verifier_hints
              payload["attestation"] = attestation

          with open(sys.argv[1], "w", encoding="utf-8") as handle:
              json.dump(payload, handle, ensure_ascii=True, indent=2)
          PY
          echo "server3_config_path=${config_path}" >> "${GITHUB_OUTPUT}"

      - name: Validate server-3 inputs
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('scripts/deploy_server3.sh') != '' }}
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "auth_security_group_id" "${RESOLVED_AUTH_SECURITY_GROUP_ID}"
          require "ami_id" "${RESOLVED_AMI_ID}"
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Deploy server-3 (if script present)
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('scripts/deploy_server3.sh') != '' }}
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ env.IMAGE_REGISTRY }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          AUTH_SECURITY_GROUP_ID: ${{ env.RESOLVED_AUTH_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          AUTH_INSTANCE_TYPE: ${{ env.RESOLVED_EDGE_INSTANCE_TYPE }}
          SERVER1_INTERNAL_ADDR: ${{ steps.resolve-server1.outputs.server1_internal_addr }}
          SERVER1_GATEWAY_URL: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
          SERVER3_CONFIG_PATH: ${{ steps.build-server3-config.outputs.server3_config_path }}
        run: bash scripts/deploy_server3.sh

      - name: Skip server-3 deploy
        if: ${{ env.RESOLVED_ENABLE_SERVER3 != 'true' }}
        run: echo "::notice::server-3 deploy disabled; skipping."

      - name: Skip server-3 deploy (script missing)
        if: ${{ env.RESOLVED_ENABLE_SERVER3 == 'true' && hashFiles('scripts/deploy_server3.sh') == '' }}
        run: echo "::warning::scripts/deploy_server3.sh not found; skipping server-3 deploy."

  stage-b:
    name: Stage B (server-2)
    needs: stage-a
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      RESOLVED_AWS_REGION: ${{ inputs.aws_region != '' && inputs.aws_region || vars.OPENPCC_AWS_REGION || 'us-east-1' }}
      RESOLVED_SUBNET_ID: ${{ inputs.subnet_id != '' && inputs.subnet_id || vars.OPENPCC_SUBNET_ID }}
      RESOLVED_COMPUTE_SECURITY_GROUP_ID: ${{ inputs.compute_security_group_id != '' && inputs.compute_security_group_id || vars.OPENPCC_COMPUTE_SECURITY_GROUP_ID }}
      RESOLVED_INSTANCE_PROFILE_ARN: ${{ inputs.instance_profile_arn != '' && inputs.instance_profile_arn || vars.OPENPCC_INSTANCE_PROFILE_ARN }}
      RESOLVED_KEY_NAME: ${{ inputs.key_name != '' && inputs.key_name || vars.OPENPCC_KEY_NAME }}
      RESOLVED_AMI_ID: ${{ inputs.ami_id != '' && inputs.ami_id || vars.OPENPCC_AMI_ID }}
      RESOLVED_COMPUTE_INSTANCE_TYPE: ${{ inputs.compute_instance_type }}
      RESOLVED_EDGE_INSTANCE_TYPE: ${{ inputs.edge_instance_type }}
      RESOLVED_ENABLE_COMPUTE_MONITOR: ${{ inputs.enable_compute_monitor }}
      RESOLVED_COMPUTE_BOOT_BUILD_TAGS: ${{ inputs.enable_fake_attestation_for_server2 && 'include_fake_attestation' || '' }}
      RESOLVED_ENCLAVE_CPU_COUNT: ${{ inputs.enclave_cpu_count != '' && inputs.enclave_cpu_count || vars.OPENPCC_ENCLAVE_CPU_COUNT || '2' }}
      RESOLVED_ENCLAVE_MEMORY_MIB: ${{ inputs.enclave_memory_mib != '' && inputs.enclave_memory_mib || vars.OPENPCC_ENCLAVE_MEMORY_MIB || '2048' }}
      RESOLVED_ENCLAVE_CID: ${{ inputs.enclave_cid != '' && inputs.enclave_cid || vars.OPENPCC_ENCLAVE_CID || '16' }}
      RESOLVED_TPM_SIMULATOR_CMD_PORT: "2321"
      RESOLVED_TPM_SIMULATOR_PLATFORM_PORT: "2322"
      SERVER1_INTERNAL_ADDR: ${{ needs.stage-a.outputs.server1_internal_addr }}
      SERVER1_ROUTER_URL: ${{ needs.stage-a.outputs.server1_router_url }}
      SERVER1_GATEWAY_URL: ${{ needs.stage-a.outputs.server1_gateway_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate AWS_ROLE_ARN
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
        run: |
          set -euo pipefail
          if [ -z "${AWS_ROLE_ARN}" ]; then
            echo "::error::Missing GitHub Actions secret AWS_ROLE_ARN."
            echo "::error::Set AWS_ROLE_ARN to the IAM Role ARN for GitHub Actions OIDC."
            echo "::error::Do not use Instance Profile ARN here."
            echo "::error::AWS Console: IAM -> Roles -> <role> -> ARN"
            echo "::error::CLI: aws iam get-role --role-name <ROLE_NAME> --query Role.Arn --output text"
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.RESOLVED_AWS_REGION }}

      - name: Resolve image registry
        id: resolve-registry
        env:
          INPUT_IMAGE_REGISTRY: ${{ inputs.image_registry }}
          VAR_IMAGE_REGISTRY: ${{ vars.OPENPCC_IMAGE_REGISTRY }}
        run: |
          set -euo pipefail
          if [ -n "${INPUT_IMAGE_REGISTRY}" ]; then
            resolved="${INPUT_IMAGE_REGISTRY}"
          elif [ -n "${VAR_IMAGE_REGISTRY}" ]; then
            resolved="${VAR_IMAGE_REGISTRY}"
          else
            echo "Missing image_registry. Set workflow input or OPENPCC_IMAGE_REGISTRY." >&2
            exit 1
          fi
          if [[ "${resolved}" != public.ecr.aws/* ]]; then
            echo "image_registry must be a public ECR registry (public.ecr.aws/alias)." >&2
            exit 1
          fi
          echo "IMAGE_REGISTRY=${resolved}" >> "$GITHUB_ENV"

      - name: Login to public ECR
        run: |
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws

      - name: Ensure ECR repositories (server-2)
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          COMPUTE_IMAGE_NAME: openpcc-compute
        run: |
          set -euo pipefail
          ensure_repo() {
            local name="$1"
            local public_region="us-east-1"
            if ! aws ecr-public describe-repositories --region "${public_region}" --repository-names "${name}" >/dev/null 2>&1; then
              echo "Creating public ECR repository: ${name}"
              aws ecr-public create-repository --region "${public_region}" --repository-name "${name}" >/dev/null
            else
              echo "Public ECR repository exists: ${name}"
            fi
          }
          ensure_repo "${COMPUTE_IMAGE_NAME}"

      - name: Validate stage B inputs
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "subnet_id" "${RESOLVED_SUBNET_ID}"
          require "compute_security_group_id" "${RESOLVED_COMPUTE_SECURITY_GROUP_ID}"
          require "server1_internal_addr" "${SERVER1_INTERNAL_ADDR}"
          require "server1_router_url" "${SERVER1_ROUTER_URL}"
          require "server1_gateway_url" "${SERVER1_GATEWAY_URL}"
          require "ami_id" "${RESOLVED_AMI_ID}"
          require "instance_profile_arn" "${RESOLVED_INSTANCE_PROFILE_ARN}"
          require "image_registry" "${IMAGE_REGISTRY}"
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Build server-2 image
        env:
          COMPONENT: server-2
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ env.IMAGE_REGISTRY }}
          COMPUTE_BOOT_BUILD_TAGS: ${{ env.RESOLVED_COMPUTE_BOOT_BUILD_TAGS }}
        run: bash scripts/build_pack.sh

      - name: Deploy server-2
        env:
          COMPONENT: server-2
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ env.IMAGE_REGISTRY }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          COMPUTE_SECURITY_GROUP_ID: ${{ env.RESOLVED_COMPUTE_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          COMPUTE_INSTANCE_TYPE: ${{ env.RESOLVED_COMPUTE_INSTANCE_TYPE }}
          ENABLE_COMPUTE_MONITOR: ${{ env.RESOLVED_ENABLE_COMPUTE_MONITOR }}
          ROUTER_ADDRESS: ${{ env.SERVER1_ROUTER_URL }}
          ENCLAVE_CPU_COUNT: ${{ env.RESOLVED_ENCLAVE_CPU_COUNT }}
          ENCLAVE_MEMORY_MIB: ${{ env.RESOLVED_ENCLAVE_MEMORY_MIB }}
          ENCLAVE_CID: ${{ env.RESOLVED_ENCLAVE_CID }}
          TPM_SIMULATOR_CMD_PORT: ${{ env.RESOLVED_TPM_SIMULATOR_CMD_PORT }}
          TPM_SIMULATOR_PLATFORM_PORT: ${{ env.RESOLVED_TPM_SIMULATOR_PLATFORM_PORT }}
        run: bash scripts/deploy_server2.sh
