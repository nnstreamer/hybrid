# Objective: One-shot build/pack/deploy workflow for OpenPCC v0.002.
# - Stage A: build/pack/deploy server-1 + server-3, then capture server-1 address.
# - Stage B: build/pack/deploy server-2 + server-4 using server-1 address.
# - Image tag is derived from the commit SHA.
# - Compute EIF is built during server-2 deploy (no S3 input needed).
name: OpenPCC v0.002 One-shot Deploy

on:
  workflow_dispatch:
    inputs:
      aws_region:
        type: string
        description: AWS region
        default: ""
      subnet_id:
        type: string
        description: Subnet ID for instances
        default: ""
      router_security_group_id:
        type: string
        description: Security group ID for server-1 (router/gateway)
        default: ""
      compute_security_group_id:
        type: string
        description: Security group ID for server-2 (compute)
        default: ""
      auth_security_group_id:
        type: string
        description: Security group ID for server-3 (auth)
        default: ""
      relay_security_group_id:
        type: string
        description: Security group ID for server-4 (relay)
        default: ""
      instance_profile_arn:
        type: string
        description: IAM instance profile ARN for EC2
        default: ""
      key_name:
        type: string
        description: Optional EC2 key pair name
        default: ""
      ami_id:
        type: string
        description: Base AMI ID (Ubuntu 22.04 recommended)
        default: ""
      router_ami_id:
        type: string
        description: server-1 AMI ID override
        default: ""
      compute_ami_id:
        type: string
        description: server-2 AMI ID override
        default: ""
      auth_ami_id:
        type: string
        description: server-3 AMI ID override
        default: ""
      relay_ami_id:
        type: string
        description: server-4 AMI ID override
        default: ""
      router_instance_type:
        type: string
        description: server-1 instance type
        default: "t3.small"
      compute_instance_type:
        type: string
        description: server-2 instance type (Nitro Enclaves enabled)
        default: "c6a.4xlarge"
      auth_instance_type:
        type: string
        description: server-3 instance type
        default: "t3.small"
      relay_instance_type:
        type: string
        description: server-4 instance type
        default: "t3.small"
      enable_compute_monitor:
        type: boolean
        description: Install compute monitor on server-2 (debug only)
        default: true
      enable_fake_attestation_for_server2:
        type: boolean
        description: Enable fake attestation for server-2 build (do not combine with real attestation for client)
        default: false
      enclave_cpu_count:
        type: string
        description: Enclave CPU count
        default: ""
      enclave_memory_mib:
        type: string
        description: Enclave memory (MiB)
        default: ""
      enclave_cid:
        type: string
        description: Enclave CID for VSOCK connections
        default: "16"
      gateway_port:
        type: string
        description: Gateway port on server-1 (relay upstream)
        default: "3200"
      ohttp_seeds_secret_ref:
        type: string
        description: Optional oHTTP seed secret reference (shared for server-1/3)
        default: ""
      enable_ohttp:
        type: boolean
        description: Enable oHTTP config in server-3
        default: true
      enable_real_attestation_for_client:
        type: boolean
        description: Enable real attestation policy for clients (do not combine with fake attestation for server-2)
        default: true
      relay_urls_json:
        type: string
        description: JSON array of relay URLs for server-3 config
        default: ""
      ohttp_seeds_json:
        type: string
        description: JSON array of oHTTP seeds for server-3 config
        default: ""
      attestation_policy_id:
        type: string
        description: Attestation policy ID for server-3 config
        default: ""
      attestation_allowed_json:
        type: string
        description: JSON object of attestation allowed values
        default: ""
      attestation_verifier_hints_json:
        type: string
        description: JSON object of attestation verifier hints
        default: ""

env:
  IMAGE_TAG: ${{ github.sha }}
  SERVER3_IMAGE_NAME: ${{ vars.OPENPCC_AUTH_IMAGE_NAME != '' && vars.OPENPCC_AUTH_IMAGE_NAME || 'openpcc-auth' }}
  SERVER4_IMAGE_NAME: ${{ vars.OPENPCC_RELAY_IMAGE_NAME != '' && vars.OPENPCC_RELAY_IMAGE_NAME || 'openpcc-relay' }}

jobs:
  stage-a:
    name: Stage A (server-1 + server-3)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      server1_internal_addr: ${{ steps.resolve-server1.outputs.server1_internal_addr }}
      server1_router_url: ${{ steps.resolve-server1.outputs.server1_router_url }}
      server1_gateway_url: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
    env:
      RESOLVED_AWS_REGION: ${{ inputs.aws_region != '' && inputs.aws_region || vars.OPENPCC_AWS_REGION || 'us-east-1' }}
      RESOLVED_SUBNET_ID: ${{ inputs.subnet_id != '' && inputs.subnet_id || vars.OPENPCC_SUBNET_ID }}
      RESOLVED_ROUTER_SECURITY_GROUP_ID: ${{ inputs.router_security_group_id != '' && inputs.router_security_group_id || vars.OPENPCC_ROUTER_SECURITY_GROUP_ID }}
      RESOLVED_AUTH_SECURITY_GROUP_ID: ${{ inputs.auth_security_group_id != '' && inputs.auth_security_group_id || vars.OPENPCC_AUTH_SECURITY_GROUP_ID }}
      RESOLVED_INSTANCE_PROFILE_ARN: ${{ inputs.instance_profile_arn != '' && inputs.instance_profile_arn || vars.OPENPCC_INSTANCE_PROFILE_ARN }}
      RESOLVED_KEY_NAME: ${{ inputs.key_name != '' && inputs.key_name || vars.OPENPCC_KEY_NAME }}
      RESOLVED_AMI_ID: ${{ inputs.ami_id != '' && inputs.ami_id || vars.OPENPCC_AMI_ID }}
      RESOLVED_ROUTER_AMI_ID: ${{ inputs.router_ami_id != '' && inputs.router_ami_id || vars.OPENPCC_ROUTER_AMI_ID }}
      RESOLVED_AUTH_AMI_ID: ${{ inputs.auth_ami_id != '' && inputs.auth_ami_id || vars.OPENPCC_AUTH_AMI_ID }}
      RESOLVED_ROUTER_INSTANCE_TYPE: ${{ inputs.router_instance_type }}
      RESOLVED_AUTH_INSTANCE_TYPE: ${{ inputs.auth_instance_type }}
      RESOLVED_GATEWAY_PORT: ${{ inputs.gateway_port != '' && inputs.gateway_port || vars.OPENPCC_GATEWAY_PORT || '3200' }}
      RESOLVED_OHTTP_SEEDS_SECRET_REF: ${{ inputs.ohttp_seeds_secret_ref != '' && inputs.ohttp_seeds_secret_ref || vars.OPENPCC_OHTTP_SEEDS_SECRET_REF }}
      RESOLVED_ENABLE_OHTTP: ${{ inputs.enable_ohttp }}
      RESOLVED_ENABLE_REAL_ATTESTATION_FOR_CLIENT: ${{ inputs.enable_real_attestation_for_client }}
      RESOLVED_ENABLE_FAKE_ATTESTATION_FOR_SERVER2: ${{ inputs.enable_fake_attestation_for_server2 }}
      RESOLVED_RELAY_URLS_JSON: ${{ inputs.relay_urls_json != '' && inputs.relay_urls_json || vars.OPENPCC_RELAY_URLS_JSON || '' }}
      RESOLVED_OHTTP_SEEDS_JSON: ${{ inputs.ohttp_seeds_json != '' && inputs.ohttp_seeds_json || secrets.OPENPCC_OHTTP_SEEDS_JSON || vars.OPENPCC_OHTTP_SEEDS_JSON || '' }}
      RESOLVED_ATTESTATION_POLICY_ID: ${{ inputs.attestation_policy_id != '' && inputs.attestation_policy_id || vars.OPENPCC_ATTESTATION_POLICY_ID || '' }}
      RESOLVED_ATTESTATION_ALLOWED_JSON: ${{ inputs.attestation_allowed_json != '' && inputs.attestation_allowed_json || secrets.OPENPCC_ATTESTATION_ALLOWED_JSON || vars.OPENPCC_ATTESTATION_ALLOWED_JSON || '' }}
      RESOLVED_ATTESTATION_VERIFIER_HINTS_JSON: ${{ inputs.attestation_verifier_hints_json != '' && inputs.attestation_verifier_hints_json || secrets.OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON || vars.OPENPCC_ATTESTATION_VERIFIER_HINTS_JSON || '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.RESOLVED_AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Validate stage A inputs
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "subnet_id" "${RESOLVED_SUBNET_ID}"
          require "router_security_group_id" "${RESOLVED_ROUTER_SECURITY_GROUP_ID}"
          require "instance_profile_arn" "${RESOLVED_INSTANCE_PROFILE_ARN}"
          require "gateway_port" "${RESOLVED_GATEWAY_PORT}"
          if [ -z "${RESOLVED_AMI_ID}" ] && [ -z "${RESOLVED_ROUTER_AMI_ID}" ]; then
            echo "Missing required AMI: ami_id or router_ami_id." >&2
            missing=1
          fi
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Build server-1 image
        env:
          COMPONENT: server-1
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: bash scripts/build_pack.sh

      - name: Build server-3 image (if present)
        if: ${{ hashFiles('server-3/Dockerfile') != '' }}
        env:
          COMPONENT: server-3
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          AUTH_IMAGE_NAME: ${{ env.SERVER3_IMAGE_NAME }}
        run: bash scripts/build_pack.sh

      - name: Skip server-3 build
        if: ${{ hashFiles('server-3/Dockerfile') == '' }}
        run: echo "::warning::server-3 Dockerfile not found; skipping build."

      - name: Deploy server-1
        env:
          COMPONENT: server-1
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          ROUTER_SECURITY_GROUP_ID: ${{ env.RESOLVED_ROUTER_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          ROUTER_AMI_ID: ${{ env.RESOLVED_ROUTER_AMI_ID }}
          ROUTER_INSTANCE_TYPE: ${{ env.RESOLVED_ROUTER_INSTANCE_TYPE }}
          # NOTE: Passed through for future gateway key sync. server-1 does not consume yet.
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
        run: bash scripts/deploy_server1.sh

      - name: Resolve server-1 address
        id: resolve-server1
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          GATEWAY_PORT: ${{ env.RESOLVED_GATEWAY_PORT }}
        run: |
          set -euo pipefail
          instance_id=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --filters "Name=tag:Name,Values=openpcc-router" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId | [0]" \
            --output text)
          if [ -z "${instance_id}" ] || [ "${instance_id}" = "None" ]; then
            echo "Failed to find running server-1 instance (tag Name=openpcc-router)." >&2
            exit 1
          fi
          private_ip=$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --instance-ids "${instance_id}" \
            --query "Reservations[0].Instances[0].PrivateIpAddress" \
            --output text)
          if [ -z "${private_ip}" ] || [ "${private_ip}" = "None" ]; then
            echo "Failed to resolve server-1 private IP." >&2
            exit 1
          fi
          # Router port is fixed at 3600. Gateway port is configurable.
          router_url="http://${private_ip}:3600"
          gateway_url="http://${private_ip}:${GATEWAY_PORT}"
          echo "server1_internal_addr=${private_ip}" >> "${GITHUB_OUTPUT}"
          echo "server1_router_url=${router_url}" >> "${GITHUB_OUTPUT}"
          echo "server1_gateway_url=${gateway_url}" >> "${GITHUB_OUTPUT}"

      - name: Build server-3 config
        id: build-server3-config
        if: ${{ hashFiles('scripts/deploy_server3.sh') != '' }}
        env:
          ENABLE_OHTTP: ${{ env.RESOLVED_ENABLE_OHTTP }}
          ENABLE_REAL_ATTESTATION_FOR_CLIENT: ${{ env.RESOLVED_ENABLE_REAL_ATTESTATION_FOR_CLIENT }}
          ENABLE_FAKE_ATTESTATION_FOR_SERVER2: ${{ env.RESOLVED_ENABLE_FAKE_ATTESTATION_FOR_SERVER2 }}
          RELAY_URLS_JSON: ${{ env.RESOLVED_RELAY_URLS_JSON }}
          OHTTP_SEEDS_JSON: ${{ env.RESOLVED_OHTTP_SEEDS_JSON }}
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
          ATTESTATION_POLICY_ID: ${{ env.RESOLVED_ATTESTATION_POLICY_ID }}
          ATTESTATION_ALLOWED_JSON: ${{ env.RESOLVED_ATTESTATION_ALLOWED_JSON }}
          ATTESTATION_VERIFIER_HINTS_JSON: ${{ env.RESOLVED_ATTESTATION_VERIFIER_HINTS_JSON }}
          SERVER1_ROUTER_URL: ${{ steps.resolve-server1.outputs.server1_router_url }}
          SERVER1_GATEWAY_URL: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
        run: |
          set -euo pipefail
          config_path="${RUNNER_TEMP}/server-3.config.json"
          python3 - <<'PY' "${config_path}"
          import json
          import os
          import sys

          def parse_bool(value, name, default):
              if value is None or value.strip() == "":
                  return default
              lowered = value.strip().lower()
              if lowered in ("true", "1", "yes", "y"):
                  return True
              if lowered in ("false", "0", "no", "n"):
                  return False
              raise SystemExit(f"{name} must be true/false (got '{value}')")

          def parse_json(raw, name, required, expected_type):
              if raw.strip() == "":
                  if required:
                      raise SystemExit(f"{name} is required")
                  return expected_type()
              try:
                  data = json.loads(raw)
              except json.JSONDecodeError as exc:
                  raise SystemExit(f"{name} must be valid JSON: {exc}") from exc
              if not isinstance(data, expected_type):
                  raise SystemExit(f"{name} must be a {expected_type.__name__} JSON value")
              return data

          def ensure_non_empty_list(values, name):
              if not values:
                  raise SystemExit(f"{name} must be a non-empty list")
              for idx, item in enumerate(values):
                  if not isinstance(item, str) or not item.strip():
                      raise SystemExit(f"{name}[{idx}] must be a non-empty string")

          enable_ohttp = parse_bool(os.getenv("ENABLE_OHTTP"), "ENABLE_OHTTP", True)
          enable_real_attestation_for_client = parse_bool(
              os.getenv("ENABLE_REAL_ATTESTATION_FOR_CLIENT"),
              "ENABLE_REAL_ATTESTATION_FOR_CLIENT",
              True,
          )
          enable_fake_attestation_for_server2 = parse_bool(
              os.getenv("ENABLE_FAKE_ATTESTATION_FOR_SERVER2"),
              "ENABLE_FAKE_ATTESTATION_FOR_SERVER2",
              False,
          )

          if enable_fake_attestation_for_server2 and enable_real_attestation_for_client:
              raise SystemExit(
                  "enable_fake_attestation_for_server2=true is not consistent with "
                  "enable_real_attestation_for_client=true. Disable one of them."
              )

          server1_router_url = os.getenv("SERVER1_ROUTER_URL", "").strip()
          server1_gateway_url = os.getenv("SERVER1_GATEWAY_URL", "").strip()
          relay_urls_raw = os.getenv("RELAY_URLS_JSON", "")
          seeds_raw = os.getenv("OHTTP_SEEDS_JSON", "")
          seeds_secret_ref = os.getenv("OHTTP_SEEDS_SECRET_REF", "").strip()

          if enable_ohttp:
              if not server1_router_url or not server1_gateway_url:
                  raise SystemExit("SERVER1_ROUTER_URL and SERVER1_GATEWAY_URL are required for oHTTP")
              relay_urls = parse_json(relay_urls_raw, "relay_urls_json", True, list)
              ensure_non_empty_list(relay_urls, "relay_urls_json")
              seeds = parse_json(seeds_raw, "ohttp_seeds_json", True, list)
              if not seeds:
                  raise SystemExit("ohttp_seeds_json must be a non-empty list")
              if not seeds_secret_ref:
                  raise SystemExit("ohttp_seeds_secret_ref is required when oHTTP is enabled")
              seen_ids = set()
              for idx, seed in enumerate(seeds):
                  if not isinstance(seed, dict):
                      raise SystemExit(f"ohttp_seeds_json[{idx}] must be an object")
                  for key in ("key_id", "seed_hex", "active_from", "active_until"):
                      value = seed.get(key)
                      if not isinstance(value, str) or not value.strip():
                          raise SystemExit(f"ohttp_seeds_json[{idx}].{key} must be a non-empty string")
                  key_id = seed["key_id"]
                  if key_id in seen_ids:
                      raise SystemExit(f"ohttp_seeds_json[{idx}].key_id is duplicated: {key_id}")
                  seen_ids.add(key_id)
          else:
              if relay_urls_raw.strip() or seeds_raw.strip() or seeds_secret_ref:
                  raise SystemExit("oHTTP inputs provided but enable_ohttp=false")
              relay_urls = []
              seeds = []

          att_policy_id = os.getenv("ATTESTATION_POLICY_ID", "").strip()
          allowed_raw = os.getenv("ATTESTATION_ALLOWED_JSON", "")
          verifier_hints_raw = os.getenv("ATTESTATION_VERIFIER_HINTS_JSON", "")

          if enable_real_attestation_for_client:
              if not att_policy_id:
                  raise SystemExit(
                      "attestation_policy_id is required when real attestation for client is enabled"
                  )
              allowed = parse_json(allowed_raw, "attestation_allowed_json", False, dict)
              verifier_hints = parse_json(
                  verifier_hints_raw, "attestation_verifier_hints_json", False, dict
              )
          else:
              if att_policy_id or allowed_raw.strip() or verifier_hints_raw.strip():
                  raise SystemExit(
                      "attestation inputs provided but enable_real_attestation_for_client=false"
                  )
              allowed = {}
              verifier_hints = {}

          payload = {
              "version": "0.002",
              "features": {
                  "ohttp": enable_ohttp,
                  "real_attestation": enable_real_attestation_for_client,
              },
          }

          if enable_ohttp:
              payload.update(
                  {
                      "relay_urls": relay_urls,
                      "gateway_url": server1_gateway_url,
                      "router_url": server1_router_url,
                      "ohttp_seeds": seeds,
                  }
              )

          if enable_real_attestation_for_client:
              attestation = {
                  "policy_id": att_policy_id,
              }
              if allowed:
                  attestation["allowed"] = allowed
              if verifier_hints:
                  attestation["verifier_hints"] = verifier_hints
              payload["attestation"] = attestation

          with open(sys.argv[1], "w", encoding="utf-8") as handle:
              json.dump(payload, handle, ensure_ascii=True, indent=2)
          PY
          echo "server3_config_path=${config_path}" >> "${GITHUB_OUTPUT}"

      - name: Validate server-3 inputs
        if: ${{ hashFiles('scripts/deploy_server3.sh') != '' }}
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "auth_security_group_id" "${RESOLVED_AUTH_SECURITY_GROUP_ID}"
          if [ -z "${RESOLVED_AUTH_AMI_ID}" ] && [ -z "${RESOLVED_AMI_ID}" ]; then
            echo "Missing required AMI: auth_ami_id or ami_id." >&2
            missing=1
          fi
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Deploy server-3 (if script present)
        if: ${{ hashFiles('scripts/deploy_server3.sh') != '' }}
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          AUTH_SECURITY_GROUP_ID: ${{ env.RESOLVED_AUTH_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          AUTH_AMI_ID: ${{ env.RESOLVED_AUTH_AMI_ID }}
          AUTH_INSTANCE_TYPE: ${{ env.RESOLVED_AUTH_INSTANCE_TYPE }}
          SERVER1_INTERNAL_ADDR: ${{ steps.resolve-server1.outputs.server1_internal_addr }}
          SERVER1_GATEWAY_URL: ${{ steps.resolve-server1.outputs.server1_gateway_url }}
          OHTTP_SEEDS_SECRET_REF: ${{ env.RESOLVED_OHTTP_SEEDS_SECRET_REF }}
          SERVER3_CONFIG_PATH: ${{ steps.build-server3-config.outputs.server3_config_path }}
        run: bash scripts/deploy_server3.sh

      - name: Skip server-3 deploy
        if: ${{ hashFiles('scripts/deploy_server3.sh') == '' }}
        run: echo "::warning::scripts/deploy_server3.sh not found; skipping server-3 deploy."

  stage-b:
    name: Stage B (server-2 + server-4)
    needs: stage-a
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      RESOLVED_AWS_REGION: ${{ inputs.aws_region != '' && inputs.aws_region || vars.OPENPCC_AWS_REGION || 'us-east-1' }}
      RESOLVED_SUBNET_ID: ${{ inputs.subnet_id != '' && inputs.subnet_id || vars.OPENPCC_SUBNET_ID }}
      RESOLVED_COMPUTE_SECURITY_GROUP_ID: ${{ inputs.compute_security_group_id != '' && inputs.compute_security_group_id || vars.OPENPCC_COMPUTE_SECURITY_GROUP_ID }}
      RESOLVED_RELAY_SECURITY_GROUP_ID: ${{ inputs.relay_security_group_id != '' && inputs.relay_security_group_id || vars.OPENPCC_RELAY_SECURITY_GROUP_ID }}
      RESOLVED_INSTANCE_PROFILE_ARN: ${{ inputs.instance_profile_arn != '' && inputs.instance_profile_arn || vars.OPENPCC_INSTANCE_PROFILE_ARN }}
      RESOLVED_KEY_NAME: ${{ inputs.key_name != '' && inputs.key_name || vars.OPENPCC_KEY_NAME }}
      RESOLVED_AMI_ID: ${{ inputs.ami_id != '' && inputs.ami_id || vars.OPENPCC_AMI_ID }}
      RESOLVED_COMPUTE_AMI_ID: ${{ inputs.compute_ami_id != '' && inputs.compute_ami_id || vars.OPENPCC_COMPUTE_AMI_ID }}
      RESOLVED_RELAY_AMI_ID: ${{ inputs.relay_ami_id != '' && inputs.relay_ami_id || vars.OPENPCC_RELAY_AMI_ID }}
      RESOLVED_COMPUTE_INSTANCE_TYPE: ${{ inputs.compute_instance_type }}
      RESOLVED_RELAY_INSTANCE_TYPE: ${{ inputs.relay_instance_type }}
      RESOLVED_ENABLE_COMPUTE_MONITOR: ${{ inputs.enable_compute_monitor }}
      RESOLVED_COMPUTE_BOOT_BUILD_TAGS: ${{ inputs.enable_fake_attestation_for_server2 && 'include_fake_attestation' || '' }}
      RESOLVED_ENCLAVE_CPU_COUNT: ${{ inputs.enclave_cpu_count != '' && inputs.enclave_cpu_count || vars.OPENPCC_ENCLAVE_CPU_COUNT || '2' }}
      RESOLVED_ENCLAVE_MEMORY_MIB: ${{ inputs.enclave_memory_mib != '' && inputs.enclave_memory_mib || vars.OPENPCC_ENCLAVE_MEMORY_MIB || '2048' }}
      RESOLVED_ENCLAVE_CID: ${{ inputs.enclave_cid != '' && inputs.enclave_cid || vars.OPENPCC_ENCLAVE_CID || '16' }}
      RESOLVED_TPM_SIMULATOR_CMD_PORT: "2321"
      RESOLVED_TPM_SIMULATOR_PLATFORM_PORT: "2322"
      SERVER1_INTERNAL_ADDR: ${{ needs.stage-a.outputs.server1_internal_addr }}
      SERVER1_ROUTER_URL: ${{ needs.stage-a.outputs.server1_router_url }}
      SERVER1_GATEWAY_URL: ${{ needs.stage-a.outputs.server1_gateway_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.RESOLVED_AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Validate stage B inputs
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "subnet_id" "${RESOLVED_SUBNET_ID}"
          require "compute_security_group_id" "${RESOLVED_COMPUTE_SECURITY_GROUP_ID}"
          require "instance_profile_arn" "${RESOLVED_INSTANCE_PROFILE_ARN}"
          require "server1_internal_addr" "${SERVER1_INTERNAL_ADDR}"
          require "server1_router_url" "${SERVER1_ROUTER_URL}"
          require "server1_gateway_url" "${SERVER1_GATEWAY_URL}"
          if [ -z "${RESOLVED_AMI_ID}" ] && [ -z "${RESOLVED_COMPUTE_AMI_ID}" ]; then
            echo "Missing required AMI: ami_id or compute_ami_id." >&2
            missing=1
          fi
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Build server-2 image
        env:
          COMPONENT: server-2
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PUSH: "true"
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          COMPUTE_BOOT_BUILD_TAGS: ${{ env.RESOLVED_COMPUTE_BOOT_BUILD_TAGS }}
        run: bash scripts/build_pack.sh

      - name: Build server-4 image (if present)
        if: ${{ hashFiles('server-4/Dockerfile') != '' }}
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          SERVER4_IMAGE_NAME: ${{ env.SERVER4_IMAGE_NAME }}
        run: |
          set -euo pipefail
          image="${REGISTRY}/${SERVER4_IMAGE_NAME}:${IMAGE_TAG}"
          echo "Building ${image} from server-4/Dockerfile"
          docker build -f server-4/Dockerfile -t "${image}" server-4
          docker push "${image}"

      - name: Skip server-4 build
        if: ${{ hashFiles('server-4/Dockerfile') == '' }}
        run: echo "::warning::server-4 Dockerfile not found; skipping build."

      - name: Validate server-4 inputs
        if: ${{ hashFiles('scripts/deploy_server4.sh') != '' }}
        run: |
          set -euo pipefail
          missing=0
          require() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              echo "Missing required value: ${name}" >&2
              missing=1
            fi
          }
          require "relay_security_group_id" "${RESOLVED_RELAY_SECURITY_GROUP_ID}"
          if [ -z "${RESOLVED_RELAY_AMI_ID}" ] && [ -z "${RESOLVED_AMI_ID}" ]; then
            echo "Missing required AMI: relay_ami_id or ami_id." >&2
            missing=1
          fi
          if [ "${missing}" -ne 0 ]; then
            exit 1
          fi

      - name: Deploy server-2
        env:
          COMPONENT: server-2
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          COMPUTE_SECURITY_GROUP_ID: ${{ env.RESOLVED_COMPUTE_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          COMPUTE_AMI_ID: ${{ env.RESOLVED_COMPUTE_AMI_ID }}
          COMPUTE_INSTANCE_TYPE: ${{ env.RESOLVED_COMPUTE_INSTANCE_TYPE }}
          ENABLE_COMPUTE_MONITOR: ${{ env.RESOLVED_ENABLE_COMPUTE_MONITOR }}
          ROUTER_ADDRESS: ${{ env.SERVER1_ROUTER_URL }}
          COMPUTE_EIF_S3_URI: ""
          ALLOW_PREBUILT_EIF: "false"
          ENCLAVE_CPU_COUNT: ${{ env.RESOLVED_ENCLAVE_CPU_COUNT }}
          ENCLAVE_MEMORY_MIB: ${{ env.RESOLVED_ENCLAVE_MEMORY_MIB }}
          ENCLAVE_CID: ${{ env.RESOLVED_ENCLAVE_CID }}
          TPM_SIMULATOR_CMD_PORT: ${{ env.RESOLVED_TPM_SIMULATOR_CMD_PORT }}
          TPM_SIMULATOR_PLATFORM_PORT: ${{ env.RESOLVED_TPM_SIMULATOR_PLATFORM_PORT }}
        run: bash scripts/deploy_server2.sh

      - name: Deploy server-4 (if script present)
        if: ${{ hashFiles('scripts/deploy_server4.sh') != '' }}
        env:
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          RELAY_SECURITY_GROUP_ID: ${{ env.RESOLVED_RELAY_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          RELAY_AMI_ID: ${{ env.RESOLVED_RELAY_AMI_ID }}
          RELAY_INSTANCE_TYPE: ${{ env.RESOLVED_RELAY_INSTANCE_TYPE }}
          RELAY_UPSTREAM_GATEWAY_URL: ${{ env.SERVER1_GATEWAY_URL }}
          SERVER1_INTERNAL_ADDR: ${{ env.SERVER1_INTERNAL_ADDR }}
        run: bash scripts/deploy_server4.sh

      - name: Skip server-4 deploy
        if: ${{ hashFiles('scripts/deploy_server4.sh') == '' }}
        run: echo "::warning::scripts/deploy_server4.sh not found; skipping server-4 deploy."
