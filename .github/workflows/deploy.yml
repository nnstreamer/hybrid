# Objective: Deploy OpenPCC router and compute nodes to AWS.
# Usage examples:
# - Run workflow_dispatch with component=server-1 and ami_id set
# - Run workflow_dispatch with component=server-2 and compute_eif_s3_uri set
# - Run workflow_dispatch with component=all and required AWS inputs set
name: OpenPCC Proto 1 Deploy

on:
  workflow_dispatch:
    inputs:
      component:
        type: choice
        description: Component to deploy
        options:
          - all
          - server-1
          - server-2
        default: all
      image_tag:
        type: string
        description: Image tag to deploy
        default: ""
      aws_region:
        type: string
        description: AWS region
        default: ""
      subnet_id:
        type: string
        description: Subnet ID for instances
        default: ""
      router_security_group_id:
        type: string
        description: Security group ID for router (server-1)
        default: ""
      compute_security_group_id:
        type: string
        description: Security group ID for compute (server-2)
        default: ""
      instance_profile_arn:
        type: string
        description: IAM instance profile ARN for EC2
        default: ""
      key_name:
        type: string
        description: Optional EC2 key pair name
        default: ""
      ami_id:
        type: string
        description: Base AMI ID (Ubuntu 22.04 recommended)
        default: ""
      router_ami_id:
        type: string
        description: Router AMI ID override
        default: ""
      compute_ami_id:
        type: string
        description: Compute AMI ID override
        default: ""
      router_instance_type:
        type: string
        description: Router instance type
        default: ""
      compute_instance_type:
        type: string
        description: Compute instance type (Nitro Enclaves enabled)
        default: ""
      router_address:
        type: string
        description: Optional router address override (for compute-only deploys)
        default: ""
      build_eif:
        type: boolean
        description: Build EIF on self-hosted runner and upload to S3
        default: false
      compute_eif_s3_uri:
        type: string
        description: Optional S3 URI for prebuilt EIF
        default: ""
      allow_prebuilt_eif:
        type: boolean
        description: Allow using compute_eif_s3_uri as-is
        default: false
      enclave_cpu_count:
        type: string
        description: Enclave CPU count
        default: ""
      enclave_memory_mib:
        type: string
        description: Enclave memory (MiB)
        default: ""

jobs:
  build-eif:
    if: ${{ inputs.build_eif == true && (inputs.component == 'all' || inputs.component == 'server-2') }}
    runs-on: [self-hosted, nitro-eif]
    env:
      RESOLVED_AWS_REGION: ${{ inputs.aws_region != '' && inputs.aws_region || vars.OPENPCC_AWS_REGION || 'us-east-1' }}
      RESOLVED_COMPUTE_EIF_S3_URI: ${{ inputs.compute_eif_s3_uri != '' && inputs.compute_eif_s3_uri || vars.OPENPCC_COMPUTE_EIF_S3_URI }}
    permissions:
      contents: read
      id-token: write
    outputs:
      compute_eif_s3_uri: ${{ steps.set-output.outputs.compute_eif_s3_uri }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate EIF inputs
        run: |
          if [ -z "${RESOLVED_COMPUTE_EIF_S3_URI}" ]; then
            echo "compute_eif_s3_uri is required when build_eif=true (input or OPENPCC_COMPUTE_EIF_S3_URI)."
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.RESOLVED_AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build EIF and upload to S3
        env:
          IMAGE_TAG: ${{ inputs.image_tag != '' && inputs.image_tag || github.sha }}
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          COMPUTE_EIF_S3_URI: ${{ env.RESOLVED_COMPUTE_EIF_S3_URI }}
        run: |
          compute_image_uri="${REGISTRY}/openpcc-compute:${IMAGE_TAG}"
          docker pull "${compute_image_uri}"
          sudo mkdir -p /opt/openpcc
          sudo nitro-cli build-enclave --docker-uri "${compute_image_uri}" \
            --output-file /opt/openpcc/compute.eif
          aws s3 cp /opt/openpcc/compute.eif "${COMPUTE_EIF_S3_URI}"

      - name: Set outputs
        id: set-output
        run: echo "compute_eif_s3_uri=${{ env.RESOLVED_COMPUTE_EIF_S3_URI }}" >> "$GITHUB_OUTPUT"

  deploy:
    needs: [build-eif]
    if: ${{ needs.build-eif.result == 'success' || needs.build-eif.result == 'skipped' }}
    runs-on: ubuntu-latest
    env:
      RESOLVED_AWS_REGION: ${{ inputs.aws_region != '' && inputs.aws_region || vars.OPENPCC_AWS_REGION || 'us-east-1' }}
      RESOLVED_SUBNET_ID: ${{ inputs.subnet_id != '' && inputs.subnet_id || vars.OPENPCC_SUBNET_ID }}
      RESOLVED_ROUTER_SECURITY_GROUP_ID: ${{ inputs.router_security_group_id != '' && inputs.router_security_group_id || vars.OPENPCC_ROUTER_SECURITY_GROUP_ID }}
      RESOLVED_COMPUTE_SECURITY_GROUP_ID: ${{ inputs.compute_security_group_id != '' && inputs.compute_security_group_id || vars.OPENPCC_COMPUTE_SECURITY_GROUP_ID }}
      RESOLVED_INSTANCE_PROFILE_ARN: ${{ inputs.instance_profile_arn != '' && inputs.instance_profile_arn || vars.OPENPCC_INSTANCE_PROFILE_ARN }}
      RESOLVED_KEY_NAME: ${{ inputs.key_name != '' && inputs.key_name || vars.OPENPCC_KEY_NAME }}
      RESOLVED_AMI_ID: ${{ inputs.ami_id != '' && inputs.ami_id || vars.OPENPCC_AMI_ID }}
      RESOLVED_ROUTER_AMI_ID: ${{ inputs.router_ami_id != '' && inputs.router_ami_id || vars.OPENPCC_ROUTER_AMI_ID }}
      RESOLVED_COMPUTE_AMI_ID: ${{ inputs.compute_ami_id != '' && inputs.compute_ami_id || vars.OPENPCC_COMPUTE_AMI_ID }}
      RESOLVED_ROUTER_INSTANCE_TYPE: ${{ inputs.router_instance_type != '' && inputs.router_instance_type || vars.OPENPCC_ROUTER_INSTANCE_TYPE || 't3.small' }}
      RESOLVED_COMPUTE_INSTANCE_TYPE: ${{ inputs.compute_instance_type != '' && inputs.compute_instance_type || vars.OPENPCC_COMPUTE_INSTANCE_TYPE || 'c5.2xlarge' }}
      RESOLVED_ROUTER_ADDRESS: ${{ inputs.router_address != '' && inputs.router_address || vars.OPENPCC_ROUTER_ADDRESS }}
      RESOLVED_COMPUTE_EIF_S3_URI: ${{ inputs.compute_eif_s3_uri != '' && inputs.compute_eif_s3_uri || needs.build-eif.outputs.compute_eif_s3_uri || vars.OPENPCC_COMPUTE_EIF_S3_URI }}
      RESOLVED_ENCLAVE_CPU_COUNT: ${{ inputs.enclave_cpu_count != '' && inputs.enclave_cpu_count || vars.OPENPCC_ENCLAVE_CPU_COUNT || '2' }}
      RESOLVED_ENCLAVE_MEMORY_MIB: ${{ inputs.enclave_memory_mib != '' && inputs.enclave_memory_mib || vars.OPENPCC_ENCLAVE_MEMORY_MIB || '2048' }}
    permissions:
      actions: write
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.RESOLVED_AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy
        env:
          COMPONENT: ${{ inputs.component }}
          AWS_REGION: ${{ env.RESOLVED_AWS_REGION }}
          IMAGE_TAG: ${{ inputs.image_tag != '' && inputs.image_tag || github.sha }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          SUBNET_ID: ${{ env.RESOLVED_SUBNET_ID }}
          ROUTER_SECURITY_GROUP_ID: ${{ env.RESOLVED_ROUTER_SECURITY_GROUP_ID }}
          COMPUTE_SECURITY_GROUP_ID: ${{ env.RESOLVED_COMPUTE_SECURITY_GROUP_ID }}
          INSTANCE_PROFILE_ARN: ${{ env.RESOLVED_INSTANCE_PROFILE_ARN }}
          KEY_NAME: ${{ env.RESOLVED_KEY_NAME }}
          AMI_ID: ${{ env.RESOLVED_AMI_ID }}
          ROUTER_AMI_ID: ${{ env.RESOLVED_ROUTER_AMI_ID }}
          COMPUTE_AMI_ID: ${{ env.RESOLVED_COMPUTE_AMI_ID }}
          ROUTER_INSTANCE_TYPE: ${{ env.RESOLVED_ROUTER_INSTANCE_TYPE }}
          COMPUTE_INSTANCE_TYPE: ${{ env.RESOLVED_COMPUTE_INSTANCE_TYPE }}
          ROUTER_ADDRESS: ${{ env.RESOLVED_ROUTER_ADDRESS }}
          COMPUTE_EIF_S3_URI: ${{ env.RESOLVED_COMPUTE_EIF_S3_URI }}
          ALLOW_PREBUILT_EIF: ${{ inputs.allow_prebuilt_eif }}
          ENCLAVE_CPU_COUNT: ${{ env.RESOLVED_ENCLAVE_CPU_COUNT }}
          ENCLAVE_MEMORY_MIB: ${{ env.RESOLVED_ENCLAVE_MEMORY_MIB }}
        run: bash scripts/deploy.sh

      - name: Persist deploy defaults
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          update_var() {
            local name="$1"
            local value="$2"
            if [ -z "${value}" ]; then
              return 0
            fi
            local update_payload
            local create_payload
            update_payload=$(VAR_VALUE="${value}" python -c 'import json, os; print(json.dumps({"value": os.environ["VAR_VALUE"]}))')
            create_payload=$(VAR_NAME="${name}" VAR_VALUE="${value}" python -c 'import json, os; print(json.dumps({"name": os.environ["VAR_NAME"], "value": os.environ["VAR_VALUE"]}))')
            local api="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/variables/${name}"
            local status
            status=$(curl -sS -o /dev/null -w "%{http_code}" -X PATCH \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${api}" \
              -d "${update_payload}")
            if [ "${status}" -eq 404 ]; then
              status=$(curl -sS -o /dev/null -w "%{http_code}" -X POST \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/variables" \
                -d "${create_payload}")
            fi
            if [ "${status}" -lt 200 ] || [ "${status}" -ge 300 ]; then
              echo "Failed to upsert variable ${name} (status ${status})." >&2
              exit 1
            fi
          }
          update_var OPENPCC_AWS_REGION "${RESOLVED_AWS_REGION}"
          update_var OPENPCC_SUBNET_ID "${RESOLVED_SUBNET_ID}"
          update_var OPENPCC_ROUTER_SECURITY_GROUP_ID "${RESOLVED_ROUTER_SECURITY_GROUP_ID}"
          update_var OPENPCC_COMPUTE_SECURITY_GROUP_ID "${RESOLVED_COMPUTE_SECURITY_GROUP_ID}"
          update_var OPENPCC_INSTANCE_PROFILE_ARN "${RESOLVED_INSTANCE_PROFILE_ARN}"
          update_var OPENPCC_ROUTER_ADDRESS "${RESOLVED_ROUTER_ADDRESS}"
          update_var OPENPCC_KEY_NAME "${RESOLVED_KEY_NAME}"
          update_var OPENPCC_AMI_ID "${RESOLVED_AMI_ID}"
          update_var OPENPCC_ROUTER_AMI_ID "${RESOLVED_ROUTER_AMI_ID}"
          update_var OPENPCC_COMPUTE_AMI_ID "${RESOLVED_COMPUTE_AMI_ID}"
          update_var OPENPCC_ROUTER_INSTANCE_TYPE "${RESOLVED_ROUTER_INSTANCE_TYPE}"
          update_var OPENPCC_COMPUTE_INSTANCE_TYPE "${RESOLVED_COMPUTE_INSTANCE_TYPE}"
          update_var OPENPCC_COMPUTE_EIF_S3_URI "${RESOLVED_COMPUTE_EIF_S3_URI}"
          update_var OPENPCC_ENCLAVE_CPU_COUNT "${RESOLVED_ENCLAVE_CPU_COUNT}"
          update_var OPENPCC_ENCLAVE_MEMORY_MIB "${RESOLVED_ENCLAVE_MEMORY_MIB}"
